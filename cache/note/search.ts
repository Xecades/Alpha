import Fuse from "fuse.js";
import type { CachedSearchFn, SearchTarget } from "@script/types";
import type { FuseIndex, IFuseOptions } from "fuse.js";
const idx = {"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["content"],"id":"content","weight":1,"src":"content","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"摊还分析","n":1},"1":{"v":"设想一个栈，在其上定义三种操作：[公式]、[公式]、[公式]。其中 [公式] 和 [公式] 顾名思义，[公式] 指连续地 [公式] 出栈中的 [公式] 个元素。 显然，[公式] 和 [公式] 都是 [公式] 的时间复杂度，而 [公式] 是 [公式] 的复杂度，其中 [公式] 为栈中元素的个数。 如果按照最坏情况来计算这个数据结构的复杂度，那么只要一次性 [公式] 出栈中所有 [公式] 个元素，就会消耗 [公式] 的时间，也就是说 最坏时间复杂度 （ Worst-case Time Complexity ）是 [公式]。但这能够代表实际使用中的表现吗？并不能，因为要想能 [公式] 出 [公式] 个元素，栈中必须至少有 [公式] 个元素，也就是说前面一定有不少于 [公式] 个复杂度为 [公式] 的 [公式] 操作。这样一均摊下来，每次操作的复杂度就是 [公式]。 像这样分析，我们得到整个数据结构的 平均时间复杂度 （ Average Time Complexity ）。但在实际研究中，要想达到真正的平均是很难的，因此我们引入 摊还时间复杂度 （ Amortized Time Complexity ）的概念，它本质上是 对平均时间复杂度上界的逼近 。 引入 在连续的 [公式] 次操作中，记 [公式] 为第 [公式] 次操作的开销（ Cost ），则 [公式] 我们希望构造出一组 摊还开销 （ Amortized Cost ） [公式]，使得 [公式] 能够反映 [公式] 的上界，即 [公式] 这样，如果我们能够想办法证明 [公式] 的，那么同时也就证明了 [公式] 也是 [公式] 的。据此，我们希望 [公式] 和 [公式] 之间的差距尽可能小，即 [公式] 在满足 非负 的同时尽可能小。 我们关注的重点即为如何构造这个 [公式]。 势能法 一种常用的分析方法是 势能法 （ Potential Method ）。它借用物理中势能的概念，给当前数据结构的状态 [公式] 赋予一个 势能 [公式]，并通过势能的变化来分析摊还开销。 取 [公式]，那么 [公式] 只要势函数 [公式] 选择得合适，保证 [公式] 始终非负，如果初始情况的势能 [公式] 为 [公式]，那么自然就保证了 [公式] 的条件。这种需求显然更容易实现。 在上面的例子中，定义势函数 [公式] 为第 [公式] 次操作后 栈中的元素个数 ，则 [公式]。对于三种操作 [公式]：[公式]，摊还开销 [公式]。 [公式]：[公式]，摊还开销 [公式]。 [公式]：[公式]，摊还开销 [公式]。 因此 [公式] 所以 [公式]。这是比最坏时间复杂度更贴近于现实的复杂度。 Splay Tree 的摊还分析 在 Splay Tree 中，我们给每个节点定义一个 [公式]： [公式] 其中 [公式] 为节点 [公式] 包括自身的后代个数。 定义 [公式] 函数的目的是模拟树高。 在一个完全二叉树中，树高为 [公式] 的节点个数为 [公式]，此时 [公式] 就是树高 [公式]。虽然 Splay Tree 不一定是完全二叉树，但 [公式] 仍然可以作为树高的一个近似。后面我们会看到，相较于直接用树高分析，[公式] 的分析更为简单。 定义树 [公式] 的势函数 [公式] 显然，[公式] 恒非负，且空树的势能为 [公式]。 Splay Tree 的操作都由 Zig、Zag、Zig-Zag 三种子操作构成。我们对于每种子操作分别分析。 Zig 操作 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝑃 𝑋 𝑃 𝑅 𝑋 𝑅 𝑋 𝐿 \"} alt=\"初始情况（[公式]）\">初始情况（[公式]） .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝑃 𝑋 𝑋 𝑅 𝑃 𝑅 𝑋 𝐿 \"} alt=\"一次 Zig 操作后（[公式]）\">一次 Zig 操作后（[公式]） [公式] 由于变换后 [公式] 降低，所以 [公式]，因此 [公式] Zig-Zag 操作 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"初始情况（[公式]）\">初始情况（[公式]） .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"一次 Zig-Zag 操作后（[公式]）\">一次 Zig-Zag 操作后（[公式]） [公式] 这里 [公式] 是因为 Zig-Zag 操作需要两次旋转。 首先 [公式]，两者抵消。 同时我们注意到不等式 [公式] 恒成立，左右同时取以 [公式] 为底的对数，得到 [公式]。在其中令 [公式]，[公式]，则 [公式] 同时由于 [公式]，最终我们得到 [公式] Zig-Zig 操作 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"初始情况（[公式]）\">初始情况（[公式]） .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"一次 Zig-Zig 操作后（[公式]）\">一次 Zig-Zig 操作后（[公式]） [公式] 注意到 [公式]。剩下的证明与 Zig-Zag 类似，此处从略。最终我们得到 [公式] 摊还分析 根据上面的分析，有 [公式] 这是一种非常优美的结构。对于一个完整的查询、插入、删除操作，它都是由一系列 Zig、Zig-Zag、Zig-Zig 子操作组成的，而这些子操作中的 [公式] 累加后 [公式] 相互抵消，只剩下初末状态的 [公式] 差值，同时我们知道末状态下 [公式] 就是根节点，也就是说 [公式] 为什么加的是常数 [公式] 呢？这是因为 Zig 永远只可能在最后一次子操作进行，最多只会执行一次。 据此，我们可以得到 Splay Tree 的摊还时间复杂度为 [公式]。 总结 上面的分析基于一个重要的假设：[公式]，但这一条件在有些情况下并不一定成立（例如 Splay Tree 初始非空）。实际上，如果这个假设不成立了，我们仍然能够得到类似的结论：只要操作次数 [公式] 足够大，总体实际表现出来的复杂度仍然为 [公式]。 [公式] 只要初始状态给定，[公式] 实际上是一个常数。在这种情况下甚至直接说 [公式] 也是合理的。如果想要更严谨一点，我们让 [公式]，这个时候常数也可以忽略不计了。","n":0.031}}},{"i":1,"$":{"0":{"v":"AVL Tree","n":0.707},"1":{"v":"AVL Tree 是在二叉搜索树的基础上实现的，对任何节点 [公式]，都有平衡因子 [公式]（其中空树高度定义为 [公式]），也即左右子树高度差不大于 [公式]。 这样得到的树虽然不一定是平衡二叉树，但能够保证高度是 [公式] 的，从而能够实现在 [公式] 的时间复杂度内完成插入、删除、查找的操作。 其中删除和查找和普通二叉搜索树并无二致，这里主要讨论插入操作。 维护 AVL Tree 平衡的方法是通过 旋转 操作，分为 LL-Rotation、LR-Rotation、RR-Rotation、RL-Rotation 这四种。 RR-Rotation 称在某个节点（不一定是根节点）的右节点（ R ight）的右子树（ R ight）上进行的 插入 操作为 RR 插入 。 如下左图，如果 [公式]、[公式] 节点的初始 [公式] 值分别为 [公式]、[公式]，在 [公式] 上进行一次 RR 插入后， 如果 [公式] 的右子树高度增加，那么 [公式]、[公式] 的 [公式] 值分别变为 [公式]、[公式]，此时 [公式] 节点不满足 AVL Tree 的条件，需要通过 RR-Rotation 操作来维护平衡（右图）。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 − 1 → − 2 𝐵 0 → − 1 𝐴 𝐿 𝐵 𝐿 𝐵 𝑅 \"} alt=\"RR-Rotation 操作前\">RR-Rotation 操作前 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐴 𝐿 𝐵 𝐿 𝐵 𝑅 \"} alt=\"RR-Rotation 操作后\">RR-Rotation 操作后 通过枚举容易证明，对于 RR 插入，只有这一种 [公式] 值需要旋转，其他 [公式] 情况要么不需要旋转，要么是在子树上进行旋转。对于后者，我们只需要保证 [公式] 是从新插入的节点往根节点回溯时遇到的第一个不平衡节点即可。 如果我们解决了 [公式] 的不平衡问题，由于 [公式] 这棵子树的高度并没有发生改变，我们已经可以断言整棵树已经平衡了（易证），在这种情况下已经没有必要继续向上回溯。 LL-Rotation LL-Rotation 与 RR-Rotation 类似，此处不再赘述。 点击展开示意图 } type=\"info\"> .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 1 → 2 𝐵 0 → 1 𝐴 𝑅 𝐵 𝑅 𝐵 𝐿 \"} alt=\"LL-Rotation 操作前\">LL-Rotation 操作前 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐵 𝑅 𝐴 𝑅 𝐵 𝐿 \"} alt=\"LL-Rotation 操作后\">LL-Rotation 操作后 LR-Rotation 顾名思义， LR-Rotation 发生在在左节点（ L eft）的右子树（ R ight）上进行插入时。 如下左图，若 [公式]、[公式]、[公式] 的初始 [公式] 值分别为 [公式]、[公式]、[公式]，在 [公式] 上进行一次 LR 插入，使得 [公式] 值分别变为 [公式]、[公式]、[公式]（[公式] 是因为我们既可能在 [公式] 的左子树上插入，也可能在右子树上插入）。这种情况下，我们需要进行 LR-Rotation 操作。 LR-Rotation 实际上是两步操作： 先在 [公式] 上进行一次 RR-Rotation； 再在 [公式] 上进行一次 LL-Rotation。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 1 → 2 𝐵 0 → 1 𝐶 0 → ± 1 𝐵 𝐿 𝐴 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 𝐵 𝐶 𝐵 𝐿 𝐴 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"在 [公式] 上进行 RR-Rotation\">在 [公式] 上进行 RR-Rotation .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐶 0 𝐵 𝐿 𝐴 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"在 [公式] 上进行 LL-Rotation\">在 [公式] 上进行 LL-Rotation 同样也可以证明，LR 插入只有这一种 [公式] 值需要旋转。并且旋转过后子树的高度没有改变，不需要继续向上回溯。 RL-Rotation 与 LR-Rotation 类似： 先在 [公式] 上进行一次 LL-Rotation； 再在 [公式] 上进行一次 RR-Rotation。 点击展开示意图 } type=\"info\"> .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 − 1 → − 2 𝐵 0 → − 1 𝐶 0 → ± 1 𝐵 𝑅 𝐴 𝐿 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 𝐵 𝐶 𝐵 𝑅 𝐴 𝐿 𝐶 𝑅 or 𝐶 𝐿 \"} alt=\"在 [公式] 上进行 LL-Rotation\">在 [公式] 上进行 LL-Rotation .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐶 0 𝐴 𝐿 𝐵 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"在 [公式] 上进行 RR-Rotation\">在 [公式] 上进行 RR-Rotation 复杂度证明 设 [公式] 为高度为 [公式] 的 AVL Tree 的 最小节点数 。为了在满足 AVL Tree 性质的前提下，使得节点数最小，任意节点 [公式] 的左右子树高度差（绝对值）一定为 [公式]。否则，如果高度相等，则一定可以再删除一个节点；如果高度差大于 [公式]，则不满足 AVL Tree 的性质。 也就是说任意高度为 [公式] 的节点一定是下图的两种情况之一： .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 ℎ ℎ − 1 ℎ − 2 \"} alt=\"空\"> .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 ℎ ℎ − 2 ℎ − 1 \"} alt=\"空\"> 从上面的分析我们得到如下等式： [公式] 等式左右同时 [公式]，得到 [公式]，说明数列 [公式] 是个类似 Fibonacci 数列的数列。 考虑边界条件，[公式]，[公式]，因此得到 [公式]。 我们知道 Fibonacci 数列的通项是 [公式] 其中 [公式] 表示离 [公式] 最近的整数。因此 [公式] 从而得到 [公式]，进而证明 AVL Tree 的插入、删除、查询操作的时间复杂度为 [公式]。 代码实现 为了计算 [公式] 值，我们需要在每个节点上维护其子树的高度信息，这是 AVL Tree 带来的额外开销。 插入函数 [公式] 的具体流程如下： 如果 [公式] 为空，返回一个新节点； 如果 [公式]，则递归插入到左子树，否则递归插入到右子树； 更新 [公式] 的高度信息； 计算 [公式] 的 [公式] 值，如果 [公式]（即不满足 AVL Tree），则根据对应的插入模式进行旋转，更新高度信息，返回新的根节点； 返回 [公式]。","n":0.024}}},{"i":2,"$":{"0":{"v":"B+ Tree","n":0.707},"1":{"v":"TBD","n":1}}},{"i":3,"$":{"0":{"v":"高级数据结构和算法分析","n":1},"1":{"v":"WIP","n":1}}},{"i":4,"$":{"0":{"v":"Leftist Heaps","n":0.707},"1":{"v":"Null Path Length （Npl(x)）：节点 x 到最近的没有两个子节点的节点（至多有一个孩子）的距离。定义 Npl(NULL) = -1 {\"Npl(X) = min{Npl(left), Npl(right)} + 1\"} Theorem: A leftist heap of r nodes on the right path must have at least 2^r - 1 nodes. TBD","n":0.169}}},{"i":5,"$":{"0":{"v":"红黑树","n":1},"1":{"v":"在二叉搜索树的基础上，给每个节点引入 [公式] 比特的颜色信息，并且让所有原本为 NULL 的指针都指向一个特殊叶节点 NIL，在此基础上满足如下规则，即为 红黑树 。 红黑树 } expand type=\"success\"> 每个节点不是红色就是黑色； 根节点是黑色； 所有叶节点 NIL 都是黑色； 红色节点的子节点一定是黑色； 从任意节点到其每个叶节点的路径上，黑色节点的数量相同。 下图为一个合法的红黑树（灰色代表红色节点）： Introduction to Algorithms , 3rd Edition: Fig 13.1 (a) NIL 的引入是为了方便边界情况的讨论。在实际应用中，为了节约空间，通常将叶节点指向同一个 NIL，把这个 NIL 作为树的属性之一。 树高复杂度 定理 } expand type=\"success\">在一个有 [公式] 个内部节点（即不包括叶节点）的红黑树中，其高度至多为 [公式]。 称从节点 [公式] 到其每个叶节点的路径上的黑色节点数量（不包括该节点）为 [公式] 的 Black-Height ，记为 [公式]。性质 5 保证了该定义的合理性。 首先，我们有如下引理： 引理 } expand>任何根节点为 [公式] 的子树至少包含 [公式] 个内部节点。 对树高进行归纳。 当树高为 [公式] 时，[公式] 为叶节点 NIL，[公式]，满足条件。 当树高大于 [公式] 时，显然 [公式] 的左右子树的 Black-Height 一定是 [公式] 或 [公式]（取决于 [公式] 自身的颜色）。由归纳假设，各个子树至少包含 [公式] 个内部节点。因此，以 [公式] 为根的树至少包含 [公式] 个内部节点。 引理得证。 设树高为 [公式]。则由性质 4，在任何从根节点到叶节点的简单路径上，黑色节点的数量至少为 [公式]（不包括根节点）。因此，根节点的 Black-Height 至少为 [公式]。因此 [公式] 简单变形后定理得证。 该定理保证了红黑树的高度是 [公式] 的。 插入 首先以普通的二叉搜索树的方式插入节点 [公式]，并将其颜色设为红色。然后调整树的结构，使其满足红黑树的性质。 记 [公式] 的父节点为 [公式]，祖父节点为 [公式]，祖父节点的另一个子节点（叔节点）为 [公式]。 如果 [公式] 为黑色，则无需任何调整；否则，[公式] 为红色，分以下三种情况讨论。 情况 1 [公式] 为红色，则 [公式] 一定是黑色。无论 [公式] 是 [公式] 的左节点还是右节点，只要将 [公式] 的颜色传递给 [公式] 和 [公式] 即可。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"调整后\">调整后 [公式] 为 [公式] 右节点的情况同理。 调整完成后，将 [公式] 作为新的 [公式] 继续向上调整。 情况 2 [公式] 为黑色，[公式] 为 [公式] 的左节点，此时 [公式] 一定是黑色。 情况 2 分为两步完成，第一步调整颜色，第二步在 [公式] 上进行 Right-Rotation。这样调整出来的树仍然满足红黑树的性质。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"颜色调整\">颜色调整 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"Right-Rotation\">Right-Rotation 对称情况同理。 调整完成后，将 [公式] 作为新的 [公式] 继续向上调整。 情况 3 [公式] 为黑色，[公式] 为 [公式] 的右节点。在 [公式] 上进行 Left-Rotation，将 [公式] 作为新的 [公式]，转为情况 2 处理。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"Left-Rotation\">Left-Rotation 代码实现 调整的伪代码实现如下： 插入调整 } expand>\n[公式] 删除 TBD.","n":0.032}}},{"i":6,"$":{"0":{"v":"Skew Heaps","n":0.707},"1":{"v":"TBD","n":1}}},{"i":7,"$":{"0":{"v":"Splay Tree","n":0.707},"1":{"v":"在二叉搜索树的基础上，每次对节点的操作（查询、插入、删除）时，通过一些类似 AVL Tree 的旋转操作 将该节点移动到根节点 。 Splay Tree 的单次操作并不能达到 [公式] 的时间复杂度（在某些情况下甚至是 [公式] 的）。但可以证明，在任何连续的 [公式] 次操作后，能够保证 [公式] 的时间复杂度（即 摊还时间复杂度 ， Amortized Time Bound ）。 假如访问了节点 [公式]（在查询、插入后，删除前）： 如果 [公式] 是根节点，不进行任何操作； 如果 [公式] 的父节点是根节点，对 [公式] 进行一次 Single Rotation （即 AVL Tree 的 LL- 或 RR-Rotation，或称 Zig 操作），使得 [公式] 移动到根节点； 否则，记 [公式] 的父节点为 [公式]，祖父节点为 [公式]，分如下两种情况讨论。 Zig-Zag Zig-Zag 分为左右对称的两种情况，都是通过 Double Rotation （LR- 或 RL-Rotation）解决，下面以其中一种情况为例。 对于如下左图，通过在 [公式]、[公式]、[公式] 上进行 LR-Rotation 操作，从而把 [公式] 移动到根节点（如右图）。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"进行 Double Rotation 之后\">进行 Double Rotation 之后 Zig-Zig 这种情况是通过两次 Single Rotation 解决的，但是需要注意 旋转的顺序 ：从上往下先对 [公式] 进行一次旋转，再对 [公式] 旋转。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"进行两次 Single Rotation 之后\">进行两次 Single Rotation 之后 复杂度证明 见 摊还分析 。","n":0.041}}},{"i":8,"$":{"0":{"v":"计算机科学","n":1}}},{"i":9,"$":{"0":{"v":"C Language Cheatsheet","n":0.577},"1":{"v":"Format String The syntax of a format placeholder is % [ parameter ] [ flags ] [ width ] [ . precision ] [ length ] type\\n \"}> * Square brackets indicate optional parts of the placeholder. Type Type Description {\"%\"} Prints {\"%\"} . {\"d\"} Decimal {\"signed int\"} . {\"u\"} Decimal {\"unsigned int\"} . {\"o\"} Octal {\"unsigned int\"} . {\"x\"} , {\"X\"} Hexadecimal {\"unsigned int\"} . {\"x\"} for lower-case and {\"X\"} for upper-case. {\"f\"} Float-point types in fixed-point notation. {\"e\"} , {\"E\"} Float-point types in exponential notation: {\"d.ddde±dd\"} . {\"e\"} for lower-case “e” and {\"E\"} for upper-case. {\"g\"} , {\"G\"} Float-point types in either fixed-point or exponential notation, whichever is more appropriate for its magnitude. {\"g\"} for lower-case and {\"G\"} for upper-case. {\"a\"} , {\"A\"} Float-point in hexadecimal notation, starting with {\"0x\"} or {\"0X\"} . {\"a\"} for lower-case and {\"A\"} for upper-case. {\"s\"} {\"null\"} -terminated string. {\"c\"} {\"char\"} . {\"p\"} {\"void*\"} in an implementation-defined format. {\"n\"} Print nothing, but writes the number of characters written so far into an integer pointer parameter. Examples: printf ( \\\"%%\\\" ) ; // % \\n printf ( \\\"%d\\\" , 123 ) ; // 123 \\n printf ( \\\"%d\\\" , - 123 ) ; // -123 \\n printf ( \\\"%u\\\" , 123 ) ; // 123 \\n printf ( \\\"%u\\\" , - 123 ) ; // 4294967173 \\n printf ( \\\"%o\\\" , 123 ) ; // 173 \\n printf ( \\\"%x\\\" , 123 ) ; // 7b \\n printf ( \\\"%X\\\" , 123 ) ; // 7B \\n printf ( \\\"%f\\\" , 123.456 ) ; // 123.456000 \\n printf ( \\\"%e\\\" , 123.456 ) ; // 1.234560e+02 \\n printf ( \\\"%E\\\" , 123.456 ) ; // 1.234560E+02 \\n printf ( \\\"%g\\\" , 123.456 ) ; // 123.456 \\n printf ( \\\"%G\\\" , 123.456 ) ; // 123.456 \\n printf ( \\\"%g\\\" , 123456789.123 ) ; // 1.23457e+08 \\n printf ( \\\"%G\\\" , 123456789.123 ) ; // 1.23457E+08 \\n printf ( \\\"%a\\\" , 123.456 ) ; // 0x1.edd2f1a9fbe77p+6 \\n printf ( \\\"%A\\\" , 123.456 ) ; // 0X1.EDD2F1A9FBE77P+6 \\n printf ( \\\"%s\\\" , \\\"Hello\\\" ) ; // Hello \\n printf ( \\\"%c\\\" , 'H' ) ; // H \\n\\n int a = 123 ; \\n printf ( \\\"%p\\\" , & a ) ; // 0x16d79b3d8 \\n\\n int n ; \\n printf ( \\\"Hello%n\\\" , & n ) ; // Hello \\n printf ( \\\"%d\\\" , n ) ; // 5 \\n \"}> Others For further information, refer to Wikipedia . Here are some common examples: printf ( \\\"[%5d]\\\" , 123 ) ; // [  123] \\n printf ( \\\"[%-5d]\\\" , 123 ) ; // [123  ] \\n printf ( \\\"[%05d]\\\" , 123 ) ; // [00123] \\n printf ( \\\"[%+5d]\\\" , 123 ) ; // [ +123] \\n printf ( \\\"[%*d]\\\" , 5 , 123 ) ; // [  123] (dynamic width) \\n printf ( \\\"[%.1f]\\\" , 123.456 ) ; // [123.5] \\n printf ( \\\"[%10f]\\\" , 123.456 ) ; // [123.456000] (10 characters in total) \\n printf ( \\\"[%10.5f]\\\" , 123.456 ) ; // [ 123.45600] (5 precision, 10 characters) \\n printf ( \\\"[%010.5f]\\\" , 123.456 ) ; // [0123.45600] (5 precision, 10 characters) \\n \"}>","n":0.043}}},{"i":10,"$":{"0":{"v":"其他","n":1}}},{"i":11,"$":{"0":{"v":"Manuals & Standards","n":0.577},"1":{"v":"Semantic Versioning Refer to : Semantic Versioning . Given a version number {\"MAJOR.MINOR.PATCH\"} , increment the: {\"MAJOR\"} version when you make incompatible API changes. {\"MINOR\"} version when you add functionality in a backward compatible manner. {\"PATCH\"} version when you make backward compatible bug fixes. Conventional Commits Refer to : Conventional Commits / Angular Convention . Structure of the commit message: <type>[optional scope]: <description>\\n\\n[optional body]\\n\\n[optional footer(s)]\\n \"}> {\"fix\"} : correlates with {\"PATCH\"} in SemVer. {\"feat\"} : correlates with {\"MINOR\"} in SemVer. {\"BREAKING CHANGE\"} : a commit that has a footer {\"BREAKING CHANGE\"} , or appends a {\"!\"} after the type/scope, correlating with {\"MAJOR\"} in SemVer. {\" \"} : {\"build\"} , {\"chore\"} , {\"ci\"} , {\"docs\"} , {\"style\"} , {\"refactor\"} , {\"perf\"} , {\"test\"} , etc. {\" \"} : use the imperative, present tense: “change” not “changed” nor “changes”. don’t capitalize the first letter. no dot ( {\".\"} ) at the end. Example: chore!: drop support for Node 6\\n\\nBREAKING CHANGE: use JavaScript features not available in Node 6.\\n \"}>","n":0.077}}},{"i":12,"$":{"0":{"v":"MIT Missing Semester","n":0.577},"1":{"v":"📖 COURSE-STARTED-AT : 2023-11-5 🔮 COURSE-FINISHED-AT : 2023-11-11 🔗 COURSE-SITE : missing.csail.mit.edu MIT Missing Semester is a course that teaches the untaught parts of computer science. Classes teach you all about advanced topics within CS, from operating systems to machine learning, but there’s one critical subject that’s rarely covered, and is instead left to students to figure out on their own: proficiency with their tools . We’ll teach you how to master the command-line, use a powerful text editor, use fancy features of version control systems, and much more! ——MIT Missing Semester For the parts I’m already familiar with, I skip them. Shell Scripting Variables To define a variable : use {\"foo=bar\"} instead of {\"foo = bar\"} . The latter tries to run a command named {\"foo\"} with arguments {\"=\"} and {\"bar\"} . To use a variable : use {\"$foo\"} . Special variables : (take {\"./script.sh foo bar\"} as an example) {\"$0\"} : {\"./script.sh\"} , name of the script. {\"$1\"} to {\"$9\"} : {\"foo\"} to {\"bar\"} , arguments to the script. {\"$@\"} : {\"foo bar\"} , all arguments. {\"$#\"} : {\"2\"} , number of arguments. {\"$?\"} : Return code of the previous command. {\"$$\"} : PID of the current script. {\"$_\"} : Last argument of the last command. Arithmetic : use {\"((x + y))\"} to do arithmetic. Use {\"$((x + y))\"} to use the result of the arithmetic. Comparisons like {\"((x >= y))\"} are also supported. Operators Operator {\"||\"} , {\"&&\"} and {\";\"} : {\"foo || bar\"} means “run {\"foo\"} , if it fails, run {\"bar\"} ”. {\"foo && bar\"} means “run {\"foo\"} , if it succeeds, run {\"bar\"} ”. {\"foo ; bar\"} means “run {\"foo\"} , then run {\"bar\"} ”. Example: false || echo \\\"Oops, fail\\\" # Oops, fail \\n true || echo \\\"Will not be printed\\\" # \\n true && echo \\\"Things went well\\\" # Things went well \\n false && echo \\\"Will not be printed\\\" # \\n true ; echo \\\"This will always run\\\" # This will always run \\n false ; echo \\\"This will always run\\\" # This will always run \\n \"}> Command substitution : use {\"$(foo)\"} to run {\"foo\"} and use its output as a string. Example: {\"for file in $(ls)\"} iterates over all files. Process substitution : {\" will run {\"foo\"} and place the output in a temporary file and substitute the {\" with that file’s name. Example: {\"diff compares the files of directory {\"foo\"} and {\"bar\"} . Redirection Input : use {\" to redirect input from a file. Output : use {\">\"} to redirect output to a file. Use {\">>\"} to append to a file. Error : use {\"2>\"} to redirect error to a file. Both output and error : use {\"&>\"} to redirect both output and error to a file. Both input and output : use {\"<>\"} to redirect both input and output to a file. Discard : redirect to {\"/dev/null\"} to discard output/error/input. Pipe : use {\"|\"} to pipe the output of a command to the input of another command. Control Flow {\"If\"} : use {\"if foo; then bar; fi\"} to run {\"bar\"} if {\"foo\"} succeeds. {\"foo\"} can be any command or a test. Refer to {\"man test\"} for more information about tests. Here are some simple examples: {\"if [[ -d foo ]];\"} : if {\"foo\"} is a directory. {\"if [[ -f foo ]];\"} : if {\"foo\"} is a file. {\"if [[ $foo -ne 0 ]];\"} : if {\"foo\"} is not equal to {\"0\"} . {\"if [[ $foo -gt 0 ]];\"} : if {\"foo\"} is greater than {\"0\"} . The {\"[[ ]]\"} notation is syntactic sugar for the {\"test\"} command. The following two lines are equivalent: if [ [ -d foo ] ] ; then \\n if test -d foo ; then \\n \"}> {\"[[ ]]\"} notation provides more features than {\"test\"} . For example, {\"[[ ]]\"} supports {\"&&\"} and {\"||\"} operators, while {\"test\"} does not. {\"For\"} , {\"While\"} and {\"Until\"} : # Run baz for each foo in bar \\n for foo in bar ; do baz ; done \\n\\n # e.g. Print all files in the current directory \\n for file in $( ls ) ; do echo $file ; done \\n\\n # Run bar while foo succeeds \\n while foo ; do bar ; done \\n\\n # e.g. Print \\\"Hello\\\" forever \\n while true ; do echo \\\"Hello\\\" ; done \\n\\n # Run bar until foo succeeds \\n until foo ; do bar ; done \\n\\n # e.g. Print \\\"Hello\\\" forever \\n until false ; do echo \\\"Hello\\\" ; done \\n \"}> Case : see the example: case $fruit in \\n    apple ) \\n echo \\\"It's an apple.\\\" \\n ; ; \\n    banana ) \\n echo \\\"It's a banana.\\\" \\n ; ; \\n    orange | lemon ) # \\\"|\\\" means \\\"or\\\" \\n echo \\\"It's an orange or a lemon.\\\" \\n ; ; \\n    * ) \\n echo \\\"It's an unknown fruit.\\\" \\n ; ; \\n esac \\n \"}> Functions : use {\"foo() { bar; }\"} to define a function named {\"foo\"} that runs {\"bar\"} . Example: multiply ( ) { \\n result = $(( $ 1 * $ 2 )) \\n echo \\\"The result of multiplication is: $result \\\" \\n } \\n\\n # Call the function \\nmultiply 5 3 \\n \"}> Others Shebang : use {\"#!/bin/bash\"} to specify the interpreter of the script. The shebang must be the first line of the script. You can also choose python as the interpreter, e.g. {\"#!/usr/bin/env python\"} . Exit code : use {\"exit 0\"} to exit with code {\"0\"} . Use {\"exit\"} to exit with the return code of the last command. Homework Write a command or script to recursively find the most recently modified file in a directory. More generally, can you list all files by recency? Here is my implementation of the first part of the homework. __check_modified ( ) { \\n local file \\n file = $( ls -t \\\" $1 \\\" | head -n1 ) \\n\\n while [ [ -d \\\" $1 / $file \\\" ] ] ; do \\n file = $( ls -t \\\" $1 / $file \\\" | head -n1 ) \\n done \\n\\n echo \\\" $1 / $file \\\" \\n } \\n\\n__check_modified \\\" $1 \\\" \\n \"}> Data Wrangling I don’t know how to document this part, so I just note down some useful tools. {\"grep\"} : search for a pattern in a file. {\"sed\"} : stream editor. {\"awk\"} : pattern scanning and processing language. {\"sort\"} : sort lines of text files. {\"uniq\"} : report or omit repeated lines. {\"paste\"} : merge lines of files. {\"wc\"} : print newline, word, and byte counts for each file. {\"tee\"} : read from standard input and write to standard output and files. {\"tr\"} : translate or delete characters. {\"tac\"} : reverse {\"cat\"} . {\"less\"} : open a file for interactive reading. {\"head\"} : output the first part of files. {\"tail\"} : output the last part of files. {\"xargs\"} : build and execute command lines from standard input. {\"bc\"} : arbitrary precision calculator language. {\"jq\"} : command-line JSON processor. {\"pup\"} : command line tool for processing HTML. One more thing : Learning Regex can be incredibly useful. It’s definitely worth investing time in! Command-line Environment Job Control When pressed {\"Ctrl-C\"} , the shell delivers a SIGINT SIGnal to the process, which by default INTerrupts the process. This python program captures SIGINT and ignores it: import signal , time\\n\\n def handler ( signum , time ) : \\n print ( \\\"\\\\nI got a SIGINT, but I am not stopping\\\" ) \\n\\nsignal . signal ( signal . SIGINT , handler ) \\n\\n # This program is a simple counter \\ni = 0 \\n while True : \\n    time . sleep ( .1 ) \\n print ( \\\"\\\\r{}\\\" . format ( i ) , end = \\\"\\\" ) \\n    i += 1 \\n \"}> When we run this program and press {\"Ctrl-C\"} , the program will continue to run. To stop it, we need to send a SIGQUIT signal to it, by typing {\"Ctrl-\\\\\"} . $ python sigint.py\\n 16 ^C\\nI got a SIGINT, but I am not stopping\\n 25 ^C\\nI got a SIGINT, but I am not stopping\\n 45 ^ \\\\ [ 1 ] 54634 quit       python sigint.py\\n \"}> Note that SIGINT and SIGQUIT can both be captured by the program. However, SIGTERM cannot. It is a more graceful way to TERMinate the process. To send the signal we can use {\"kill -TERM \"} or {\"kill \"} for short. {\"Ctrl-Z\"} is used to suspend a process. It sends a SIGTSTP signal, short for “terminal stop”. When a process is suspended, it pauses. Command {\"jobs\"} lists the unfinished jobs associated with the current terminal session. For example, if I suspended the {\"sigint.py\"} program above: $ python sigint.py\\n 25 ^Z\\n [ 1 ] + 56852 suspended  python sigint.py\\n$ jobs \\n [ 1 ] + suspended  python sigint.py\\n \"}> Then we can use {\"fg\"} to bring the job to the foreground, and {\"bg\"} to the background. $ fg %1 # %1 means it is the first job \\n [ 1 ] + 56852 continued  python sigint.py\\n 75 # Number counting continues \\n \"}> By using the {\"&\"} suffix, a command runs in the background but still prints to the terminal. To background a program we can use {\"Ctrl-Z\"} and {\"bg\"} , but note that the process will die if you close the terminal. To prevent this, we can use {\"nohup\"} to run the program in the background, it sets the process to ignores SIGHUP signal, which is sent to a process when the terminal session ends. $ nohup python sigint.py & \\n \"}> To get a comprehensive list of signals, check {\"man signal\"} . Terminal Multiplexers Refer to Tmux . Here is a tutorial: A Quick and Easy Guide to tmux . Version Control (Git) Here I list some useful commands that I’m not familiar with. I won’t dig into that too much. $ git log --all --graph --decorate \\n$ git clone --shallow \\n$ git fetch\\n$ git stash\\n$ git stash pop\\n \"}> Metaprogramming Here is an example of a simple Makefile that compiles a LaTeX document. paper.pdf : paper.tex plot-data.png\\n\tpdflatex paper.tex\\n\\n plot-%.png : %.dat plot.py\\n\t./plot.py -i $*.dat -o $@ \\n \"}> Security and Cryptography Cryptographic hash function Cryptographic hash functions map an arbitrary length input to a fixed-length output. The general model is hash(value: array<byte>) -> vector<byte, N>  (for some fixed N)\\n \"}> It has the following properties: Deterministic : the same input maps to the same output. Non-invertible : it is hard to find an input m such that {\"hash(m) = h\"} for some desired output {\"h\"} . Target collision resistant : given an input {\"m1\"} , it’s hard to find a different input {\"m2\"} such that {\"hash(m1) = hash(m2)\"} . Collision resistant : it’s hard to find two inputs {\"m1\"} and {\"m2\"} such that {\"hash(m1) = hash(m2)\"} (this is a strictly stronger property than target collision resistance). Note that it is hard to find a collision, but it is not completely impossible . This is why each cryptographic hash function has a lifespan . A widely used cryptographic hash function is SHA-1 . For example, Git uses SHA-1 to identify commits. But it is not secure anymore . To generate an SHA-1 hash, we can use the {\"shasum\"} command on macOS. $ echo \\\"hello, world\\\" | shasum -a 1 \\ncd50d19784897085a8d0e3e413f8612b097c03f1  -\\n \"}> Imagine we’re playing a number-guessing game. I’ve thought of a random number, and you’re trying to guess it. You need to share your guess before I reveal if it’s correct. Now, to ensure I don’t cheat by altering the number in my mind, we can employ a cryptographic hash function. Before you make your guess, I’ll share the hash of my number. After the game, you can verify that I haven’t tampered with the chosen number by checking the hash of your guessed number. Key derivation function Key derivation functions , or KDFs , share similarities with cryptographic hash functions, but they are specifically designed for deriving secret keys from a given input, typically a password or a low-entropy key. KDFs are intentionally designed to operate at a slow pace, making it time-consuming to brute-force the password. Applications : Producing keys from passphrases for use in other cryptographic algorithms (e.g. symmetric cryptography). Storing login credentials. Storing plaintext passwords is bad; the right approach is to generate and store a random salt {\"salt = random()\"} for each user, store {\"KDF(password + salt)\"} , and verify login attempts by re-computing the KDF given the entered password and the stored salt. Symmetric cryptography Symmetric cryptography is used to encrypt and decrypt data. It uses a secret key to encrypt and decrypt data. The same key is used for both encryption and decryption. The model is keygen() -> key  (this function is randomized)\\n\\nencrypt(plaintext: array<byte>, key) -> array<byte>  (the ciphertext)\\ndecrypt(ciphertext: array<byte>, key) -> array<byte>  (the plaintext)\\n \"}> An example of a symmetric cryptosystem in wide use today is AES. Asymmetric cryptography Except for encrypting and decrypting data, asymmetric cryptography can also be used to sign and verify data. It uses a public key and a private key . The public key is used to encrypt data and verify signatures, while the private key is used to decrypt data and sign data. The model is keygen() -> (public-key, private-key)  (this function is randomized)\\n\\nencrypt(plaintext: array<byte>, public-key) -> array<byte>  (the ciphertext)\\ndecrypt(ciphertext: array<byte>, private-key) -> array<byte>  (the plaintext)\\n\\nsign(message: array<byte>, private-key) -> array<byte>  (the signature)\\nverify(message: array<byte>, signature: array<byte>, public-key) -> bool  (whether or not the signature is valid)\\n \"}> As its name suggests, public key can be made public. Anyone can use the public key to encrypt data for you , but only you, with the corresponding private key, can decrypt it. That’s how private messaging apps like Telegram works. On the flip side, you can sign data using your private key. Others can then verify the signature using your public key. This mechanism is exemplified in practices such as verifying commits in Git through digital signatures.","n":0.021}}},{"i":13,"$":{"0":{"v":"笔记","n":1}}},{"i":14,"$":{"0":{"v":"Français","n":1},"1":{"v":"字母表 字母 音标 字母 音标 Aa {\"[a]\"} Nn {\"[ɛn]\"} Bb {\"[be]\"} Oo {\"[o]\"} Cc {\"[se]\"} Pp {\"[pe]\"} Dd {\"[de]\"} Qq {\"[ky]\"} Ee {\"[ə]\"} Rr {\"[ɛr]\"} Ff {\"[ɛf]\"} Ss {\"[ɛs]\"} Gg {\"[ʒe]\"} Tt {\"[te]\"} Hh {\"[aʃ]\"} Uu {\"[y]\"} Ii {\"[i]\"} Vv {\"[ve]\"} Jj {\"[ʒi]\"} Ww {\"[dubləve]\"} Kk {\"[ka]\"} Xx {\"[iks]\"} Ll {\"[ɛl]\"} Yy {\"[iɡrɛk]\"} Mm {\"[ɛm]\"} Zz {\"[zɛd]\"} 音素 元音 ： {\"[a] [ɔ] [œ] [ɛ] [o] [ø] [e] [ə] [u] [y] [i] [ɑ̃] [ɛ̃] [œ̃] [ɔ̃]\"} 辅音 ： {\"[p] [b] [t] [d] [f] [v] [k] [g] [s] [z] [ʃ] [ʒ] [m] [n] [ɲ] [l] [r]\"} 半元音 ： {\"[j] [ч] [w]\"} 发音规则 元音 音素 读音规则 例词 {\"[a]\"} a, à, â sa, là, âme {\"[ɛ]\"} è, ê mère, fête ai, ei fait, veine e 在闭音节中 sel e 在两个相同的辅音字母前 cette et 在词末 filet {\"[i]\"} i, î, ï mie, île, maïs y style {\"[e]\"} é bébé es 在单音节词中 des er, ez 在词末 fêter {\"[fɛte]\"} , aidez {\"[ɛde]\"} {\"[y]\"} u, û tu {\"[ty]\"} , dû, culture {\"[kyltyr]\"} {\"[ə]\"} e 在词首开音节中 chemise {\"ʃəmiz\"} e 在单音节词中 ce {\"[sə]\"} e 在“辅辅 e 辅元”中 vendredi {\"[ã]\"} am, an 后无 m, n 或元音字母 lampe, dans em, en 后无 m, n 或元音字母 temps {\"[tã]\"} , vent {\"[vã]\"} , an {\"[ã]\"} 辅音 音素 读音规则 例词 {\"[s]\"} s tasse ç ça, français c 在元音字母 e, i, y 前 face, cidre, cycle {\"[t]\"} t, th ta, thé {\"[d]\"} d date {\"[f]\"} f fade ph phare {\"[v]\"} v vie {\"[m]\"} m mais {\"[ʃ]\"} ch chaise {\"[ʃɛz]\"} , chine {\"[ʃin]\"} {\"[ʒ]\"} j jupe {\"[ʒyp]\"} , déjà {\"[deʒa]\"} g 在元音字母 e, i, y 前 âge, gile, gymnase {\"[k]\"} k kaki c 在元音字母 a, o, u 或辅音字母前 car, code {\"[kɔd]\"} , cube, classe c 在词尾 lac {\"lak\"} qu quel {\"[kɛl]\"} {\"[g]\"} g 在元音字母 a, o, u 或辅音字母前 gare, gomme, légume, glace gu 在元音字母 e, i, y 前 guerre, guide {\"[r]\"} r rire, revue {\"[rəvy]\"} {\"[z]\"} z zèle s 在两个元音字母之间 Asie","n":0.057}}},{"i":15,"$":{"0":{"v":"杂项","n":1}}},{"i":16,"$":{"0":{"v":"自定义语法","n":1},"1":{"v":"数学公式 利用 KaTeX 渲染数学公式。 行内公式 ... $ < 公式内容 > $ ...\\n \"}> 效果 可以不难推得 [公式]。 [公式] 这个名字来源于单词 Decade：[公式]。 源码 可以不难推得 $\\\\varphi(n):=n\\\\prod_{p\\\\mid n}(1-\\\\frac{1}{p})$。\\n\\n$\\\\mathfrak{Xecades}$ 这个名字来源于单词 Decade：$\\\\text{10 Decades}\\\\rightarrow \\\\text{X Decades}\\\\rightarrow \\\\text{Xecades}$。\\n \"}> 行间公式 $$\\n < 公式内容 > \\n$$\\n \"}> 效果 [公式] 源码 $$\\n\\\\begin{aligned}\\n&\\\\Bigl(f*g\\\\Bigr)(6) \\\\\\\\\\n=&\\\\sum_{d\\\\mid 6}f(d)g\\\\biggl(\\\\dfrac{6}{d}\\\\biggr) \\\\\\\\\\n=&f(1)g(6)+f(2)g(3)+f(3)g(2)+f(6)g(1)\\n\\\\end{aligned}\\n$$\\n \"}> Icon 使用 FontAwesome 加载 SVG 图标。 ... : < icon > : ...\\n \"}> 效果 The magic spell will lead you to the treasure . 源码 The * magic spell * :arrow-up: :arrow-up: :arrow-down: :arrow-down: :arrow-left: :arrow-right: :arrow-left: :arrow-right: :a: :b: :a: :b: will lead you to the treasure :sack-dollar:.\\n \"}> 引言 适合用于展示名言、引用等。 ::quote\\n < 引言内容 > \\n::\\n \"}> 效果 Two roads diverged in a wood, and I— I took the one less traveled by , And that has made all the difference. —Robert Frost 源码 :::quote\\nTwo roads diverged in a wood, and I—\\\\\\nI took * the one less traveled by * ,\\\\\\nAnd that has made all the difference.\\\\\\n < right > —Robert Frost </ right > \\n:::\\n \"}> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. [公式] Note 功能上类似于 MkDocs Material 的 Admonitions ，用于提供额外信息。 ::note{[default] | primary | success | info | warning | danger}\\n < Note 内容 > \\n::\\n \"}> 效果 这里是 {\"note.default\"} 的内容 源码 :::note\\n这里是 `note.default` 的内容\\n:::\\n \"}> 效果 [公式] 源码 :::note{danger}\\n$\\\\text{P} \\\\neq \\\\text{NP}$\\n:::\\n \"}> 这里是 {\"note.primary\"} 的内容 这里是 {\"note.success\"} 的内容 这里是 {\"note.info\"} 的内容 这里是 {\"note.warning\"} 的内容 这里是 {\"note.danger\"} 的内容 Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 折叠面板 ::fold{title=\\\"[标题]\\\" [ expand ] [ default ] | primary | success | info | warning | danger}\\n < 折叠内容 > \\n::\\n \"}> 效果 默认展开的 {\"default\"} 折叠面板 } expand>这里是 {\"fold.default\"} 的内容 源码 :::fold{title=\\\"默认展开的 `default` 折叠面板\\\" expand}\\n这里是 `fold.default` 的内容\\n:::\\n \"}> {\"primary\"} 折叠面板 } type=\"primary\">这里是 {\"fold.primary\"} 的内容 {\"success\"} 折叠面板 } type=\"success\">这里是 {\"fold.success\"} 的内容 {\"info\"} 折叠面板 } type=\"info\">这里是 {\"fold.info\"} 的内容 {\"warning\"} 折叠面板 } type=\"warning\">这里是 {\"fold.warning\"} 的内容 {\"danger\"} 折叠面板 } type=\"danger\">这里是 {\"fold.danger\"} 的内容 标题是支持 [公式] 的 } expand type=\"success\"> 折叠面板也支持 [公式]！ [公式] Lorem } type=\"danger\"> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Veniam irure ipsum dolore dolore Lorem voluptate adipisicing eiusmod minim. Eu incididunt enim irure nisi. Amet eu nostrud irure Lorem mollit eu ipsum excepteur cillum irure in sint reprehenderit deserunt. Occaecat adipisicing culpa excepteur magna id dolor exercitation ut ea dolor ut veniam est eiusmod. Consequat qui ut labore dolor ut. Ipsum ullamco commodo veniam occaecat fugiat sint consectetur nisi deserunt sunt ullamco et veniam. Do commodo mollit voluptate veniam ipsum irure dolore nisi. 这个折叠面板没有标题 这个折叠面板的标题真的真的真的真的真的真的真的真的真的真的真的真的非常的长，而且里面还有 {\"code\"} 块 }> print ( \\\"Hello World\\\" ) \\n \"}> 链接卡片 ::linkcard{href=\\\" < 链接地址 > \\\"}\\n < 链接名称 > \\n::\\n \"}> 效果 Xecades 的博客 源码 :::linkcard{href=\\\"https://blog.xecades.xyz/\\\"}\\nXecades 的博客\\n:::\\n \"}> [公式] 的 GitHub 仓库 Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Typst 渲染 基于 Typst.ts 实现 Typst 的渲染。 ```typst [标题]\\n<Typst 代码>\\n```\\n \"}> 效果 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 15 13 12 14 17 16 18 18 \"} alt=\"一棵来自 Typst 的树\">一棵来自 Typst 的树 源码 ``` typst 一棵来自 ***Typst*** 的树 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([15], ([13], [12], [14]), ([17], [16], ([18], [], [18])))\\n    )\\n}) \\n ``` \\n \"}> 选项卡 ::tab\\n # <选项卡 1> \\n\\n < 选项卡 1 内容 > \\n\\n # <选项卡 2> \\n\\n < 选项卡 2 内容 > \\n\\n[...]\\n::\\n \"}> 选项卡 1 这里是「 选项卡 1 」 的内容 选项卡 2 这里是「 选项卡 2 」 的内容 [公式] 公式 选项卡也是支持 [公式] 的！ [公式] Lorem Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 一个名字很长很长很长很长很长很长的选项卡（而且名字里面还有 {\"code\"} ） print ( \\\"Hello World\\\" ) \\n \"}> 源码 :::tab\\n # 选项卡 1 \\n\\n这里是「 ** 选项卡 1 ** 」 的内容\\n\\n # 选项卡 2 \\n\\n这里是「 ** 选项卡 2 ** 」 的内容\\n\\n # $\\\\LaTeX$ 公式 \\n\\n选项卡也是支持 $\\\\LaTeX$ 的！\\n\\n$$\\n\\\\begin{aligned}\\n&\\\\Bigl(f*g\\\\Bigr)(6) \\\\\\\\\\n=&\\\\sum_{d\\\\mid 6}f(d)g\\\\biggl(\\\\dfrac{6}{d}\\\\biggr) \\\\\\\\\\n=&f(1)g(6)+f(2)g(3)+f(3)g(2)+f(6)g(1)\\n\\\\end{aligned}\\n$$\\n\\n # Lorem \\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\n\\n # 一个名字很长很长很长很长很长很长的选项卡（而且名字里面还有 `code`） \\n\\n ``` python \\n print ( \\\"Hello World\\\" ) \\n ``` \\n:::\\n \"}> 唯一一个 Tab！ 这个选项卡只有这一个 Tab Grid ::grid\\n:sep{width=\\\" < 宽度 > \\\"}\\n\\n < 内容 1 > \\n\\n:sep{width=\\\" < 宽度 > \\\"}\\n\\n < 内容 2 > \\n\\n[...]\\n::\\n \"}> 效果 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 20 16 13 18 25 21 28 \"} alt=\"二叉搜索树 例 1\"> 二叉搜索树 例 1 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 10 5 2 7 15 \"} alt=\"二叉搜索树 例 2\"> 二叉搜索树 例 2 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 15 13 12 14 17 16 18 18 \"} alt=\"二叉搜索树 例 3\"> 二叉搜索树 例 3 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 16 10 7 1 15 19 17 18 20 \"} alt=\"二叉搜索树 例 4\"> 二叉搜索树 例 4 源码 :::grid\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 1 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([20], ([16], [13], [18]), ([25], [21], [28]))\\n    )\\n}) \\n ``` \\n\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 2 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([10], ([5], [2], [7]), [15])\\n    )\\n}) \\n ``` \\n\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 3 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([15], ([13], [12], [14]), ([17], [16], ([18], [], [18])))\\n    )\\n}) \\n ``` \\n\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 4 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([16], ([10], ([7], [1], []), [15]), ([19], ([17], [], [18]), [20]))\\n    )\\n}) \\n ``` \\n\\n:::\\n \"}>","n":0.023}}},{"i":17,"$":{"0":{"v":"测试","n":1}}},{"i":18,"$":{"0":{"v":"LaTeX 测试","n":0.707},"1":{"v":"狄利克雷卷积 （Dirichlet Convolution）在解析数论中是一个非常重要的工具. 使用狄利克雷卷积可以很方便地推出 莫比乌斯反演 （Möbius Inversion）相关重要函数和公式，它在信息学竞赛和解析数论中至关重要. 很多初学者不能真正地理解莫比乌斯反演，或者说即使能使用最终的公式，也难以理清楚它是怎么推导的. 本文中，我将尝试使用一种新的方式讲解狄利克雷卷积和莫比乌斯反演，希望能对大家有所帮助. 文中的引语（浅色文字）是可选内容，为正文的补充或提示. 阅读时，你可以选择跳过这部分文字，而不会影响内容连贯性. 什么是狄利克雷卷积 狄利克雷卷积是定义在 数论函数 间的二元运算. 所谓 数论函数 ，是指定义域为 [公式]（ 自然数 ），值域为 [公式]（ 复数 ） 的一类函数，每个数论函数可以视为复数的序列. 它最常见的定义式为： [公式] 这里提醒一个很明显的事实：在这个定义式中，右式的函数 [公式] 和 [公式] 括号中的参数是可以调换的，即： [公式] 如果我们比较关注式子的对称性，下面有狄利克雷卷积的另一个定义式： [公式] 下面举一个例子，以方便理解： [公式] 在后面的文章中我们会反复应用这两个定义式. 为什么叫“狄利克雷卷积”呢？ 首先， 狄利克雷 （Gustav Lejeune Dirichlet）是 19 世纪德国的数学家，他是解析数论的创立者，是解析数论很多重要理论的提出者. 至于“卷”，可以理解为在二维平面上延伸的两个数论函数（一个沿 x 轴，一个沿 y 轴）像卷毛巾一样交叉结合起来. “积”这个字在定义式中的星号 [公式] 体现出来了，如果定义普通函数加法为数论函数间的“加”运算，那么这里的狄利克雷卷积就是数论函数的“乘”运算，这一点我会在后文再次提到. 本文要用到的数论函数 还记得到吗？数论函数都是 [公式] 类型的. 下面我来列举一些常用的数论函数. 初看时你可能会觉得这些定义没有什么用，但它们在狄利克雷卷积中大多是作为记号存在的. 单位函数 [公式] [公式] 幂函数 [公式] [公式] 特别地，有： 当 [公式] 时，为 恒等函数 [公式]，即 [公式]. 当 [公式] 时，为 常数函数 [公式]，即 [公式]. 这里的常数函数 [公式] 的函数名是 加粗了 的数字 [公式]，不要和 [公式] 弄混了.\n在某些场合，有人会用大写字母 [公式] 来代替 [公式]，以防混淆，这里还是使用 [公式]. 除数函数 [公式] 直观上理解，除数函数就是其所有因数的 [公式] 次方之和. [公式] 特别地，有： 当 [公式] 时，为 因数函数 [公式]，即 [公式]. 当 [公式] 时，为 个数函数 [公式]，即 [公式]. 从“因数函数”和“个数函数”这两个名字就可以看出来，[公式] 表示 [公式] 的因数之和，[公式] 表示 [公式] 的因数个数. 例如，[公式]，[公式]. 对于因数函数和个数函数，设 [公式]，其中 [公式]，可以得到这两个计算式（不是重点，证明从略）： [公式] 欧拉函数 [公式] 欧拉函数博大精深，这里只介绍一些内容. [公式] 表示小于 [公式] 的正整数中与 [公式] 互质的数的个数. 可以不难推知（证明从略）： [公式] 总共（提及的）有： 单位函数 [公式]、 幂函数 [公式]（含 恒等函数 [公式] 和 常数函数 [公式]）、 除数函数 [公式]（含 因数函数 [公式] 和 个数函数 [公式]）、 欧拉函数 [公式]. 上面提到的 所有 函数都是 积性函数 ，其中 单位函数 和 幂函数 是 完全积性函数 （证明从略）. 积性函数 是指对 所有互质的整数 [公式] 和 [公式] 都有 [公式] 的数论函数. 完全积性函数 是指对 所有整数 [公式] 和 [公式] 都有 [公式] 的数论函数. 在 [公式] 式中令 [公式]，得到 [公式]，这也是积性函数一重要特点. 狄利克雷卷积相关定理 读者不妨先不看证明，自己试着证一下. [1] 若 [公式]，[公式] 为积性函数，则 [公式] 也是积性函数. 设 [公式]（即 [公式] 和 [公式] 互质）则： [公式] 在将 [公式] 合并成 [公式] 的操作中，用到了由 [公式]、[公式] 互质推导出来的结论：[公式] 的因数唯一表示为 [公式] 的因数与 [公式] 的因数的乘积，因此 [公式] 和 [公式] 是完全等价的. [2] 狄利克雷卷积满足交换律，即 [公式]. [公式] 在 [公式] 中，我将 [公式] 和 [公式] 换了个位置（也就是 [公式] 写成 [公式]，[公式] 写成 [公式]. 实际上这不是必须的），然后把 [公式] 挪到了 [公式] 的前面. 这里我用的是第二个定义式，它的优点是对称性好，用来证明交换律很直观. [3] 狄利克雷卷积满足结合律，即 [公式]. [公式] 从 [公式] 开始，类似地也可以得到 [公式]，因此它们相等，结合律成立. [4] 狄利克雷卷积满足分配律，即 [公式]. [公式] 这里总结一下我们证了的式子： 若 [公式]，[公式] 为积性函数，则 [公式] 也是积性函数. 狄利克雷卷积满足 交换律 ，即 [公式]. 狄利克雷卷积满足 结合律 ，即 [公式]. 狄利克雷卷积满足 分配律 ，即 [公式]. 这些结论十分重要，后文中我可能会在不说明的情况下直接使用这些结论. 为什么是“积”？ 现在我们可以得出原因了，狄利克雷卷积满足 交换律 、 结合律 和 分配律 ，其运算法则和普通算数乘法完全类似（在小学的时候我们就已经学过乘法的三定律了）. 实际上，狄利克雷卷积和普通函数加法可以构成一个 阿贝尔环 ，你甚至可以在它的基础上构建以函数为自变量的多项式，并解它的根. 一些特殊的卷积 看到这里，前文提到的数论函数才能真正地起作用. [1] [公式] [公式] 在证明的过程中，我们发现：如果一个函数和 [公式] 作狄利克雷卷积，就相当于把其参数的所有因子枚举出来并代入原函数，然后求和. 也就是说： [公式] 无论是正向操作还是反向操作，这个式子都很重要. [2] [公式] 再提醒一下，[公式] 的定义是这样的： [公式] 首先有： [公式] 尝试对 [公式] 进行拆分，当 [公式] 时，有： [公式] 考虑更普遍的情况，当 [公式] 为任意正整数，分解 [公式]，因为 [公式] 是积性函数，所以： [公式] 综上，[公式]. [3] [公式] 这个证明相对更简单. [公式] 上面我们只列举出了三个常用的狄利克雷卷积结果，分别是： [公式]; [公式]; [公式]. 实际上，通过这几个运算我们可以得到更多的运算，例如： [公式] 单位元 乘法的 单位元 是指乘上它后值不改变的数（对狄利克雷卷积来说，是“函数”）. 例如，普通乘法的单位元是数字 [公式]，因为 [公式]. 因此，在狄利克雷卷积中，它的单位元 [公式] 就应该满足 [公式]. 我们注意到这样一个事实： [公式] 因此，狄利克雷卷积的单位元就是 单位函数 [公式]，它在狄利克雷卷积中的作用和 1 在普通乘法中的作用是类似的. 任何函数（ 包括 [公式] ）和 [公式] 进行狄利克雷卷积，都得到该函数本身. 还记得到吗？[公式] 的定义是这样的： [公式] 狄利克雷逆（Dirichlet Inverse） 我们可以把这里的“ 逆 ”和“ 逆元 ”作类比. 例如，在普通运算中，一个数的“逆元”就是这个数的倒数；在同余运算中，一个数的“逆元”在同个模的意义下，能使得它与这个数相乘的结果与 [公式] 同余. 分别而言，如果我们规定 [公式] 的逆元是 [公式]（这个符号是作为整体引入的， 大多数情况下不能简单地理解为 [公式] ），那么就有这样两个式子： [公式] 数字 [公式] 是两种运算中的单位元，所以说，逆元在类似乘法的运算中起着“倒数”的地位. 在狄利克雷卷积中，单位元是 [公式]，我们定义狄利克雷逆如下： [公式] 函数 [公式] 就被称为 [公式] 的 狄利克雷逆 . 对于狄利克雷逆公式的推导，可以使用 合情推理 的方法（列出 [公式]，然后找规律），得到狄利克雷逆的计算式： [公式] 这个式子我们不推导，仅证明它是成立的: 当 [公式] 时，[公式]. 当 [公式] 时， [公式] 也就是说，[公式]. 因此这个计算式是成立的. 值得注意的是，狄利克雷逆的计算式中包含了自身，也就是说它是个 递归形式的定义 . 若将其展开，则过于复杂，（一般）没有实际意义. 一个数论函数 [公式] 存在狄利克雷逆的 充要条件 是 [公式]，在狄利克雷逆的推导过程中，我们知道 [公式] 的逆是唯一的 . 需要指出， 积性函数一定有狄利克雷逆，且它也是积性函数 ，该证明从略（请参见芝加哥大学 Mark Schachner 的 Paper ）. 当 [公式] 且 [公式] 时，有 [公式]，证明如下： [公式] 由狄利克雷逆的唯一性，[公式] 的狄利克雷逆是唯一的，所以 [公式]. 莫比乌斯反演 说了这么多，终于到莫比乌斯反演了. 了解了狄利克雷卷积和狄利克雷逆，莫比乌斯反演就不在话下了. 我们定义单位函数 [公式] 的狄利克雷逆为 莫比乌斯函数 [公式] （或译作“默比乌斯函数”）： [公式] 上面这个式子就是莫比乌斯函数的狄利克雷逆定义式，如果用普通写法，莫比乌斯函数的普通定义式为： [公式] 其证明请参见 Mark Schachner 的 Paper 中的 Theorem 4.3. 互联网上不少介绍莫比乌斯反演的文章只给第二种定义，是因为莫比乌斯反演的讲解可以绕过狄利克雷卷积独立进行，但这样做会让一些读者不明白为什么这样定义，平添了许多麻烦. 我认为，在理解狄利克雷卷积的基础上谈论莫比乌斯反演是事半功倍的. 使用狄利克雷卷积来推导莫比乌斯反演公式就易如反掌了： [公式] 将其展开，也就是： [公式] 莫比乌斯反演公式的证明十分简单，在 [公式] 式的左式中同时卷积 [公式] 即可. 参考文献 芝加哥大学 Mark Schachner 的论文： Algebraic and Analytic Properties of Arithmetic Functions ; Wikipedia Dirichlet Convolution 条目 ; Pecco 知乎专栏《狄利克雷卷积》 ; Wikipedia Arithmetic Function 条目 . 感谢阅读，如果发现有误或不当的地方，我诚恳地希望您在下方评论区指出. 关于莫比乌斯反演公式的应用及延伸，我会在下一篇文章中提及，敬请期待.","n":0.045}}},{"i":19,"$":{"0":{"v":"Markdown 测试","n":0.707},"1":{"v":"普通文字 二级标题 三级标题 四级标题 五级标题 六级标题 选中 未选中 Sunt ullamco esse esse sit aliquip aliquip ea laboris ea nulla. Quis eiusmod enim aliqua consectetur sit ea. Commodo anim enim sit qui nisi culpa labore fugiat nisi est nulla ad. Dolore dolor magna Lorem sunt dolor commodo eu ad aliquip officia officia incididunt deserunt. Adipisicing veniam aliquip incididunt et amet velit nulla quis magna culpa aliqua nulla. Lorem proident Lorem nostrud elit quis quis id duis incididunt reprehenderit. Magna do ipsum incididunt nisi nisi do et consectetur excepteur amet. Irure qui aute incididunt velit consectetur nisi et sint elit dolor voluptate. Magna et non ullamco minim commodo amet culpa anim ea excepteur consequat pariatur laboris. Duis reprehenderit ipsum officia duis ut veniam. Ex deserunt labore velit minim laboris veniam magna velit exercitation ea minim. Velit amet veniam aute minim. Dolore occaecat officia minim dolor cupidatat ut sint. Tempor voluptate aliquip consectetur excepteur culpa. Et dolor in adipisicing commodo ex magna dolore ut aliquip. Nulla nisi nulla commodo id proident sit proident dolor dolore ipsum ullamco. Fugiat Lorem est sunt excepteur Lorem officia labore. Ut et tempor in exercitation nostrud amet eiusmod. Exercitation incididunt dolore cupidatat mollit veniam esse reprehenderit eiusmod cillum eu tempor dolor aliqua minim. Laboris voluptate consequat exercitation nisi ipsum. Cillum anim voluptate sunt est nostrud magna quis ad irure. 斜体 、 粗体 、 加粗斜体 、 删除线 在一个段落中的 文字链接 ，然后是后面的文字。 无序列表项 1 无序列表项 2 无序列表项 3 有序列表项 1 有序列表项 2 有序列表项 3 图片展示 这里是图片标题，支持 [公式] 和 加粗 文字 {\"cat /data/flag\"} 三级引用。Proident id dolore consectetur eu nulla anim sint magna veniam culpa mollit anim nostrud elit. Laboris ullamco nulla officia esse deserunt est aliqua. Ex deserunt mollit consectetur consequat duis deserunt et pariatur. Labore pariatur dolor ut excepteur amet ex fugiat amet tempor ullamco aute. Cupidatat non nulla ut laborum dolor nostrud quis quis. 二级引用。Exercitation aliquip commodo voluptate sit nulla. Voluptate laborum commodo esse elit culpa velit. Occaecat consequat pariatur deserunt nulla reprehenderit eiusmod. Consequat nostrud labore do laborum anim duis laborum proident laboris elit. Enim culpa aliqua voluptate aliqua dolor esse nisi culpa consectetur anim minim sint nulla incididunt. 一级引用。Et amet ea anim ut excepteur consequat amet dolore. Nulla incididunt do et minim do ea consequat aute dolore. Eiusmod exercitation proident aliqua et officia laborum occaecat reprehenderit exercitation ea ut fugiat pariatur. Anim do veniam ex pariatur proident quis id aute consequat incididunt excepteur quis tempor id. 多个引用 多个引用 多个引用 Cupidatat consequat incididunt nostrud laborum incididunt in sunt aute. Elit consectetur consectetur qui fugiat incididunt laborum amet officia quis cupidatat amet ut ullamco. Esse sunt aliqua commodo qui laboris sint enim. 行内代码块 {\"#include \"} 。Mollit dolore est in et aliquip adipisicing et nulla id nulla esse laborum minim nulla. In ad irure qui magna Lorem ad eiusmod do do {\"laborum ex duis\"} . Reprehenderit nulla nisi laborum incididunt voluptate sunt et cupidatat commodo consectetur deserunt. Non officia aliquip enim duis. Ea irure magna excepteur labore eiusmod officia sit id sint anim ipsum duis labore Lorem. Culpa cillum {\"voluptate duis exercitation cillum esse incididunt laborum magna\"} . Est ut commodo non magna nisi sit proident deserunt consectetur ut anim ullamco ut adipisicing. {\"scanf()\"} 用于输入数据，而 {\"printf()\"} 用于输出数据。 表格 Type Description {\"%\"} Prints {\"%\"} . {\"d\"} Decimal {\"signed int\"} . {\"u\"} Decimal {\"unsigned int\"} . {\"o\"} Octal {\"unsigned int\"} . {\"x\"} , {\"X\"} Hexadecimal {\"unsigned int\"} . {\"x\"} for lower-case and {\"X\"} for upper-case. {\"f\"} Float-point types in fixed-point notation. {\"e\"} , {\"E\"} Float-point types in exponential notation: {\"d.ddde±dd\"} . {\"e\"} for lower-case “e” and {\"E\"} for upper-case. {\"g\"} , {\"G\"} Float-point types in either fixed-point or exponential notation, whichever is more appropriate for its magnitude. {\"g\"} for lower-case and {\"G\"} for upper-case. {\"a\"} , {\"A\"} Float-point in hexadecimal notation, starting with {\"0x\"} or {\"0X\"} . {\"a\"} for lower-case and {\"A\"} for upper-case. {\"s\"} {\"null\"} -terminated string. {\"c\"} {\"char\"} . {\"p\"} {\"void*\"} in an implementation-defined format. {\"n\"} Print nothing, but writes the number of characters written so far into an integer pointer parameter. 代码块 # include <stdio.h> \\n\\n int main ( ) \\n { \\n printf ( \\\"Hello world\\\\n\\\" ) ; \\n printf ( \\\"Nulla culpa ut laborum sint esse elit minim sit. Eiusmod et exercitation et laboris voluptate aute et veniam excepteur. Anim dolore culpa commodo adipisicing et aute. In est aliquip duis tempor cillum ullamco qui. Et officia cillum ex et dolor esse magna veniam. Dolor sint velit dolor commodo in. Irure excepteur adipisicing dolore ipsum velit ipsum nisi Lorem pariatur dolor excepteur dolor dolor.\\\\n\\\" ) ; \\n return 0 ; \\n } \\n \"}> 这个代码块不带语言标识\\nlet a = 1;\\n \"}>","n":0.036}}},{"i":20,"$":{"0":{"v":"数理","n":1}}},{"i":21,"$":{"0":{"v":"线性代数","n":1}}},{"i":22,"$":{"0":{"v":"Prove That...","n":0.707},"1":{"v":"C’mon, prove these linear algebra things! For the content below, I use [公式] to denote [公式] is a subspace of [公式], and [公式] to denote “there exists a unique”. Group, Ring & Field [公式] is a field. [公式] is the smallest number field (i.e. subfield of [公式]). Linear Space For [公式], [公式] is closed under addition and scalar multiplication. [公式]. If [公式] and [公式] are linearly independent, then [公式]. Functions [公式], [公式] and [公式] are linearly independent. ([公式], [公式] and [公式] are distinct) For [公式]: [公式] or [公式]. [公式]. [公式]. For [公式], the following propositions are equivalent: [公式]. [公式], [公式] and [公式] such that [公式]. If [公式], then [公式]. [公式]. Inner Product Space ( Cauchy–Schwarz inequality ) [公式]. ( Triangle inequality ) [公式]. ( Pythagorean theorem ) [公式]. ( Gram–Schmidt process ) Any Euclidean space has an orthonormal basis. (The method to construct it is called Gram–Schmidt process.) If [公式] is an orthonormal basis of [公式], then [公式], [公式]. Linear Transformation [公式] is injective [公式]. [公式] is surjective [公式]. If [公式] is a basis of [公式], then [公式], [公式] such that [公式]. For [公式], [公式]. For [公式], if [公式], the following propositions are equivalent: [公式] is injective. [公式] is surjective. [公式]. [公式]. Matrix [公式] and [公式] are one-to-one. Prove with matrix: if [公式], [公式], then [公式]. Prove with matrix: [公式].","n":0.067}}},{"i":23,"$":{"0":{"v":"What is...","n":0.707},"1":{"v":"Here are some easy-to-forget terms in linear algebra. Check whether you are familiar with them all. Set Power set , or [公式] and [公式] for a set [公式]. Group and Field Semigroup . Monoid . Group , or [公式]. Abelian group . Field , or [公式]. Vector Space Dimension , or [公式]. Rank , or [公式]. For [公式], what is [公式], [公式]. Inner product space . Euclidean space . Schmidt orthonormalization .","n":0.118}}},{"i":24,"$":{"0":{"v":"Cheatsheet","n":1},"1":{"v":"Disclaimer : By saying “cheatsheet” I don’t mean something used for cheating, but rather a quick reference for the most important concepts and formulas. I don’t encourage cheating in any way. Equivalent Infinitesimals When [公式]: [公式] [公式] [公式] [公式] Derivatives [公式] [公式] [公式] [公式] Integrals [公式] [公式] [公式] [公式] [公式] [公式], [公式] [公式], [公式] [公式] [公式] [公式] [公式] [公式] Taylor Series With [公式] and [公式]: [公式] [公式] [公式] [公式] [公式] [公式] [公式] [公式] [公式] [公式]","n":0.115}}},{"i":25,"$":{"0":{"v":"Completeness of the Real Numbers","n":0.447},"1":{"v":"Least upper bound property Every nonempty subset of [公式] having an upper bound has a least upper bound. Monotone convergence theorem If a sequence of [公式] is monotone and bounded, then it converges. Nested interval theorem For a sequence of closed intervals [公式], if [公式] for all [公式] and [公式], then exists exactly one [公式] so that [公式] for all [公式]. Bolzano-Weierstrass theorem Every bounded sequence of [公式] has a convergent subsequence. Cauchy criterion A sequence of [公式] is convergent if and only if it is a fundamental sequence. Fundamental sequence : A sequence [公式] is called a fundamental sequence if for all [公式], exists [公式] so that [公式] for all [公式] and [公式]. Fundamental sequence is also known as Cauchy sequence. Heine-Borel theorem If [公式] is an infinite open cover of closed interval [公式], then exists a finite subset [公式] so that [公式] is an open cover of [公式]. Or: If [公式] which satisfies [公式], then exists a finite subset [公式] so that [公式].","n":0.078}}},{"i":26,"$":{"0":{"v":"数学分析","n":1}}},{"i":27,"$":{"0":{"v":"Prove That...","n":0.707},"1":{"v":"Here are theorems and proofs that are essential in mathematical analysis. It would be nice if you could prove them smoothly. Set ( De Morgan’s laws ) [公式] [公式] Any countable union of countable sets is a countable set. Limit of a sequence Prove with definition: [公式]. If [公式], then [公式]. For convergent sequences [公式] and [公式], if [公式], [公式], and [公式], then exists [公式] so that [公式] for all [公式]. If [公式], [公式], then [公式]. [公式] and [公式] converges to [公式]. [公式] converges to [公式]. [公式] converges to [公式]. [公式]. [公式] is convergent [公式] every non-trivial subsequence [公式] of [公式] converges. [公式] is divergent. Prove with Nested interval theorem : [公式] is uncountable. Refer to Completeness of the Real Numbers , and prove Least upper bound [公式] Monotone convergence . Monotone convergence [公式] Nested interval . Nested interval [公式] Bolzano-Weierstrass . Bolzano-Weierstrass [公式] Cauchy criterion . Cauchy criterion [公式] Least upper bound . Cauchy criterion [公式] Nested interval . Nested interval [公式] Least upper bound . Limit of a function If [公式], [公式] and [公式], then exists [公式] so that [公式] for all [公式]. If [公式], then exists [公式] so that [公式] is bounded in [公式]. Prove with definition: [公式]. ( Heine’s theorem ) The necessary and sufficient condition for [公式] is that for all sequences [公式] which converges to [公式] and [公式], [公式]. Prove with Heine’s theorem : [公式] has no limit as [公式]. ( Cauchy criterion ) Prove with Heine’s theorem : [公式] exists if and only if for all [公式], exists [公式] so that [公式] for all [公式]. Prove with definition: [公式]. Continuity Every irrational point of [公式] is continuous, every rational point of [公式] is removable discontinuous, where [公式] If [公式] is continuous at [公式], and [公式] is continuous at [公式], then [公式] is continuous at [公式]. If [公式] is continuous in closed interval [公式], then it is bounded in [公式]. then [公式] and [公式] exists in [公式]. and [公式], then exists [公式] so that [公式]. then it can reach all values between [公式] and [公式]. ( Cantor’s theorem ) then it is uniformly continuous in [公式]. The sufficient and necessary condition for [公式] to be uniformly continuous in [公式] is that for all sequences [公式] that satisfies [公式], [公式]. If [公式] is continuous in finite open interval [公式], then [公式] is uniformly continuous on [公式] if and only if [公式] and [公式] exist. Derivative ( Darboux’s theorem ) If [公式] is differentiable in [公式], then for every [公式] between [公式] and [公式], there exists [公式] so that [公式]. ( Rolle’s theorem ) If [公式] is continuous in [公式], differentiable in [公式], and [公式], then exists [公式] so that [公式]. If [公式] is twice differentiable in [公式], and [公式], then [公式], [公式], such that [公式]. If [公式] is bounded in [公式], then [公式] is uniformly continuous in [公式]. If [公式] is twice differentiable at [公式], [公式], and [公式], find [公式] and [公式]. (answer: [公式] and [公式]) point out two mistakes: [公式]. Prove using Taylor series with Lagrange remainder : [公式] is irrational.","n":0.044}}},{"i":28,"$":{"0":{"v":"Ch.27 Gauss' Law","n":0.577},"1":{"v":"流量 Flux 流量 } expand>单位时间流过某表面的体积。 对于平面 [公式]： [公式] 一般式： [公式] 对于闭合曲面，若内部无源无汇，则 [公式]；若有源，则 [公式]，代表流出；若有汇，则 [公式]，代表流入。 Gauss’ Law 电通量 } expand>[公式] Gauss’ Law } expand type=\"success\">\n[公式] [公式]：闭合曲面内包围的电荷量。 [公式]：电荷体积密度。 [公式] 算符：[公式] 微分形式推导 首先由于数学上的 高斯公式 ，有 [公式] 而 [公式] 两式相等，故有 [公式] 证毕。 推 Coloumb’s Law 点电荷周围电场球形对称，取半径为 [公式] 的球面为高斯面，有 [公式] 故 [公式]，即 [公式] 即为 Coulomb’s Law。 应用 均匀带电球体 均匀带电球体 } expand>半径为 [公式] 的均匀带电球体，电荷密度为 [公式]，求球体内外的电场强度。 当 [公式] 时，取半径为 [公式] 的球面为高斯面，有 [公式] 故 [公式]（和点电荷的结果一致）。 当 [公式] 时，有 [公式] 其中 [公式] 故 [公式]（[公式]）。 电荷分布于导体表面 首先导体内电场一定为 [公式]，否则会有电荷在导体内部运动，违背静电平衡。 因此 [公式]，故 [公式]，即导体内部电荷量为 [公式]，说明导体所有电荷都分布于表面。 TBD","n":0.11}}},{"i":29,"$":{"0":{"v":"物理学","n":1}}}]};
const db: SearchTarget[] = [{"title":"摊还分析","content":"设想一个栈，在其上定义三种操作：[公式]、[公式]、[公式]。其中 [公式] 和 [公式] 顾名思义，[公式] 指连续地 [公式] 出栈中的 [公式] 个元素。 显然，[公式] 和 [公式] 都是 [公式] 的时间复杂度，而 [公式] 是 [公式] 的复杂度，其中 [公式] 为栈中元素的个数。 如果按照最坏情况来计算这个数据结构的复杂度，那么只要一次性 [公式] 出栈中所有 [公式] 个元素，就会消耗 [公式] 的时间，也就是说 最坏时间复杂度 （ Worst-case Time Complexity ）是 [公式]。但这能够代表实际使用中的表现吗？并不能，因为要想能 [公式] 出 [公式] 个元素，栈中必须至少有 [公式] 个元素，也就是说前面一定有不少于 [公式] 个复杂度为 [公式] 的 [公式] 操作。这样一均摊下来，每次操作的复杂度就是 [公式]。 像这样分析，我们得到整个数据结构的 平均时间复杂度 （ Average Time Complexity ）。但在实际研究中，要想达到真正的平均是很难的，因此我们引入 摊还时间复杂度 （ Amortized Time Complexity ）的概念，它本质上是 对平均时间复杂度上界的逼近 。 引入 在连续的 [公式] 次操作中，记 [公式] 为第 [公式] 次操作的开销（ Cost ），则 [公式] 我们希望构造出一组 摊还开销 （ Amortized Cost ） [公式]，使得 [公式] 能够反映 [公式] 的上界，即 [公式] 这样，如果我们能够想办法证明 [公式] 的，那么同时也就证明了 [公式] 也是 [公式] 的。据此，我们希望 [公式] 和 [公式] 之间的差距尽可能小，即 [公式] 在满足 非负 的同时尽可能小。 我们关注的重点即为如何构造这个 [公式]。 势能法 一种常用的分析方法是 势能法 （ Potential Method ）。它借用物理中势能的概念，给当前数据结构的状态 [公式] 赋予一个 势能 [公式]，并通过势能的变化来分析摊还开销。 取 [公式]，那么 [公式] 只要势函数 [公式] 选择得合适，保证 [公式] 始终非负，如果初始情况的势能 [公式] 为 [公式]，那么自然就保证了 [公式] 的条件。这种需求显然更容易实现。 在上面的例子中，定义势函数 [公式] 为第 [公式] 次操作后 栈中的元素个数 ，则 [公式]。对于三种操作 [公式]：[公式]，摊还开销 [公式]。 [公式]：[公式]，摊还开销 [公式]。 [公式]：[公式]，摊还开销 [公式]。 因此 [公式] 所以 [公式]。这是比最坏时间复杂度更贴近于现实的复杂度。 Splay Tree 的摊还分析 在 Splay Tree 中，我们给每个节点定义一个 [公式]： [公式] 其中 [公式] 为节点 [公式] 包括自身的后代个数。 定义 [公式] 函数的目的是模拟树高。 在一个完全二叉树中，树高为 [公式] 的节点个数为 [公式]，此时 [公式] 就是树高 [公式]。虽然 Splay Tree 不一定是完全二叉树，但 [公式] 仍然可以作为树高的一个近似。后面我们会看到，相较于直接用树高分析，[公式] 的分析更为简单。 定义树 [公式] 的势函数 [公式] 显然，[公式] 恒非负，且空树的势能为 [公式]。 Splay Tree 的操作都由 Zig、Zag、Zig-Zag 三种子操作构成。我们对于每种子操作分别分析。 Zig 操作 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝑃 𝑋 𝑃 𝑅 𝑋 𝑅 𝑋 𝐿 \"} alt=\"初始情况（[公式]）\">初始情况（[公式]） .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝑃 𝑋 𝑋 𝑅 𝑃 𝑅 𝑋 𝐿 \"} alt=\"一次 Zig 操作后（[公式]）\">一次 Zig 操作后（[公式]） [公式] 由于变换后 [公式] 降低，所以 [公式]，因此 [公式] Zig-Zag 操作 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"初始情况（[公式]）\">初始情况（[公式]） .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"一次 Zig-Zag 操作后（[公式]）\">一次 Zig-Zag 操作后（[公式]） [公式] 这里 [公式] 是因为 Zig-Zag 操作需要两次旋转。 首先 [公式]，两者抵消。 同时我们注意到不等式 [公式] 恒成立，左右同时取以 [公式] 为底的对数，得到 [公式]。在其中令 [公式]，[公式]，则 [公式] 同时由于 [公式]，最终我们得到 [公式] Zig-Zig 操作 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"初始情况（[公式]）\">初始情况（[公式]） .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"一次 Zig-Zig 操作后（[公式]）\">一次 Zig-Zig 操作后（[公式]） [公式] 注意到 [公式]。剩下的证明与 Zig-Zag 类似，此处从略。最终我们得到 [公式] 摊还分析 根据上面的分析，有 [公式] 这是一种非常优美的结构。对于一个完整的查询、插入、删除操作，它都是由一系列 Zig、Zig-Zag、Zig-Zig 子操作组成的，而这些子操作中的 [公式] 累加后 [公式] 相互抵消，只剩下初末状态的 [公式] 差值，同时我们知道末状态下 [公式] 就是根节点，也就是说 [公式] 为什么加的是常数 [公式] 呢？这是因为 Zig 永远只可能在最后一次子操作进行，最多只会执行一次。 据此，我们可以得到 Splay Tree 的摊还时间复杂度为 [公式]。 总结 上面的分析基于一个重要的假设：[公式]，但这一条件在有些情况下并不一定成立（例如 Splay Tree 初始非空）。实际上，如果这个假设不成立了，我们仍然能够得到类似的结论：只要操作次数 [公式] 足够大，总体实际表现出来的复杂度仍然为 [公式]。 [公式] 只要初始状态给定，[公式] 实际上是一个常数。在这种情况下甚至直接说 [公式] 也是合理的。如果想要更严谨一点，我们让 [公式]，这个时候常数也可以忽略不计了。","link":"/note/cs/ads/amortized-analysis","is_index":false},{"title":"AVL Tree","content":"AVL Tree 是在二叉搜索树的基础上实现的，对任何节点 [公式]，都有平衡因子 [公式]（其中空树高度定义为 [公式]），也即左右子树高度差不大于 [公式]。 这样得到的树虽然不一定是平衡二叉树，但能够保证高度是 [公式] 的，从而能够实现在 [公式] 的时间复杂度内完成插入、删除、查找的操作。 其中删除和查找和普通二叉搜索树并无二致，这里主要讨论插入操作。 维护 AVL Tree 平衡的方法是通过 旋转 操作，分为 LL-Rotation、LR-Rotation、RR-Rotation、RL-Rotation 这四种。 RR-Rotation 称在某个节点（不一定是根节点）的右节点（ R ight）的右子树（ R ight）上进行的 插入 操作为 RR 插入 。 如下左图，如果 [公式]、[公式] 节点的初始 [公式] 值分别为 [公式]、[公式]，在 [公式] 上进行一次 RR 插入后， 如果 [公式] 的右子树高度增加，那么 [公式]、[公式] 的 [公式] 值分别变为 [公式]、[公式]，此时 [公式] 节点不满足 AVL Tree 的条件，需要通过 RR-Rotation 操作来维护平衡（右图）。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 − 1 → − 2 𝐵 0 → − 1 𝐴 𝐿 𝐵 𝐿 𝐵 𝑅 \"} alt=\"RR-Rotation 操作前\">RR-Rotation 操作前 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐴 𝐿 𝐵 𝐿 𝐵 𝑅 \"} alt=\"RR-Rotation 操作后\">RR-Rotation 操作后 通过枚举容易证明，对于 RR 插入，只有这一种 [公式] 值需要旋转，其他 [公式] 情况要么不需要旋转，要么是在子树上进行旋转。对于后者，我们只需要保证 [公式] 是从新插入的节点往根节点回溯时遇到的第一个不平衡节点即可。 如果我们解决了 [公式] 的不平衡问题，由于 [公式] 这棵子树的高度并没有发生改变，我们已经可以断言整棵树已经平衡了（易证），在这种情况下已经没有必要继续向上回溯。 LL-Rotation LL-Rotation 与 RR-Rotation 类似，此处不再赘述。 点击展开示意图 } type=\"info\"> .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 1 → 2 𝐵 0 → 1 𝐴 𝑅 𝐵 𝑅 𝐵 𝐿 \"} alt=\"LL-Rotation 操作前\">LL-Rotation 操作前 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐵 𝑅 𝐴 𝑅 𝐵 𝐿 \"} alt=\"LL-Rotation 操作后\">LL-Rotation 操作后 LR-Rotation 顾名思义， LR-Rotation 发生在在左节点（ L eft）的右子树（ R ight）上进行插入时。 如下左图，若 [公式]、[公式]、[公式] 的初始 [公式] 值分别为 [公式]、[公式]、[公式]，在 [公式] 上进行一次 LR 插入，使得 [公式] 值分别变为 [公式]、[公式]、[公式]（[公式] 是因为我们既可能在 [公式] 的左子树上插入，也可能在右子树上插入）。这种情况下，我们需要进行 LR-Rotation 操作。 LR-Rotation 实际上是两步操作： 先在 [公式] 上进行一次 RR-Rotation； 再在 [公式] 上进行一次 LL-Rotation。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 1 → 2 𝐵 0 → 1 𝐶 0 → ± 1 𝐵 𝐿 𝐴 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 𝐵 𝐶 𝐵 𝐿 𝐴 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"在 [公式] 上进行 RR-Rotation\">在 [公式] 上进行 RR-Rotation .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐶 0 𝐵 𝐿 𝐴 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"在 [公式] 上进行 LL-Rotation\">在 [公式] 上进行 LL-Rotation 同样也可以证明，LR 插入只有这一种 [公式] 值需要旋转。并且旋转过后子树的高度没有改变，不需要继续向上回溯。 RL-Rotation 与 LR-Rotation 类似： 先在 [公式] 上进行一次 LL-Rotation； 再在 [公式] 上进行一次 RR-Rotation。 点击展开示意图 } type=\"info\"> .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 − 1 → − 2 𝐵 0 → − 1 𝐶 0 → ± 1 𝐵 𝑅 𝐴 𝐿 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 𝐵 𝐶 𝐵 𝑅 𝐴 𝐿 𝐶 𝑅 or 𝐶 𝐿 \"} alt=\"在 [公式] 上进行 LL-Rotation\">在 [公式] 上进行 LL-Rotation .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐶 0 𝐴 𝐿 𝐵 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"在 [公式] 上进行 RR-Rotation\">在 [公式] 上进行 RR-Rotation 复杂度证明 设 [公式] 为高度为 [公式] 的 AVL Tree 的 最小节点数 。为了在满足 AVL Tree 性质的前提下，使得节点数最小，任意节点 [公式] 的左右子树高度差（绝对值）一定为 [公式]。否则，如果高度相等，则一定可以再删除一个节点；如果高度差大于 [公式]，则不满足 AVL Tree 的性质。 也就是说任意高度为 [公式] 的节点一定是下图的两种情况之一： .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 ℎ ℎ − 1 ℎ − 2 \"} alt=\"空\"> .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 ℎ ℎ − 2 ℎ − 1 \"} alt=\"空\"> 从上面的分析我们得到如下等式： [公式] 等式左右同时 [公式]，得到 [公式]，说明数列 [公式] 是个类似 Fibonacci 数列的数列。 考虑边界条件，[公式]，[公式]，因此得到 [公式]。 我们知道 Fibonacci 数列的通项是 [公式] 其中 [公式] 表示离 [公式] 最近的整数。因此 [公式] 从而得到 [公式]，进而证明 AVL Tree 的插入、删除、查询操作的时间复杂度为 [公式]。 代码实现 为了计算 [公式] 值，我们需要在每个节点上维护其子树的高度信息，这是 AVL Tree 带来的额外开销。 插入函数 [公式] 的具体流程如下： 如果 [公式] 为空，返回一个新节点； 如果 [公式]，则递归插入到左子树，否则递归插入到右子树； 更新 [公式] 的高度信息； 计算 [公式] 的 [公式] 值，如果 [公式]（即不满足 AVL Tree），则根据对应的插入模式进行旋转，更新高度信息，返回新的根节点； 返回 [公式]。","link":"/note/cs/ads/avl-tree","is_index":false},{"title":"B+ Tree","content":"TBD","link":"/note/cs/ads/b-plus-tree","is_index":false},{"title":"高级数据结构和算法分析","content":"WIP","link":"/note/cs/ads","is_index":true},{"title":"Leftist Heaps","content":"Null Path Length （Npl(x)）：节点 x 到最近的没有两个子节点的节点（至多有一个孩子）的距离。定义 Npl(NULL) = -1 {\"Npl(X) = min{Npl(left), Npl(right)} + 1\"} Theorem: A leftist heap of r nodes on the right path must have at least 2^r - 1 nodes. TBD","link":"/note/cs/ads/leftist-heaps","is_index":false},{"title":"红黑树","content":"在二叉搜索树的基础上，给每个节点引入 [公式] 比特的颜色信息，并且让所有原本为 NULL 的指针都指向一个特殊叶节点 NIL，在此基础上满足如下规则，即为 红黑树 。 红黑树 } expand type=\"success\"> 每个节点不是红色就是黑色； 根节点是黑色； 所有叶节点 NIL 都是黑色； 红色节点的子节点一定是黑色； 从任意节点到其每个叶节点的路径上，黑色节点的数量相同。 下图为一个合法的红黑树（灰色代表红色节点）： Introduction to Algorithms , 3rd Edition: Fig 13.1 (a) NIL 的引入是为了方便边界情况的讨论。在实际应用中，为了节约空间，通常将叶节点指向同一个 NIL，把这个 NIL 作为树的属性之一。 树高复杂度 定理 } expand type=\"success\">在一个有 [公式] 个内部节点（即不包括叶节点）的红黑树中，其高度至多为 [公式]。 称从节点 [公式] 到其每个叶节点的路径上的黑色节点数量（不包括该节点）为 [公式] 的 Black-Height ，记为 [公式]。性质 5 保证了该定义的合理性。 首先，我们有如下引理： 引理 } expand>任何根节点为 [公式] 的子树至少包含 [公式] 个内部节点。 对树高进行归纳。 当树高为 [公式] 时，[公式] 为叶节点 NIL，[公式]，满足条件。 当树高大于 [公式] 时，显然 [公式] 的左右子树的 Black-Height 一定是 [公式] 或 [公式]（取决于 [公式] 自身的颜色）。由归纳假设，各个子树至少包含 [公式] 个内部节点。因此，以 [公式] 为根的树至少包含 [公式] 个内部节点。 引理得证。 设树高为 [公式]。则由性质 4，在任何从根节点到叶节点的简单路径上，黑色节点的数量至少为 [公式]（不包括根节点）。因此，根节点的 Black-Height 至少为 [公式]。因此 [公式] 简单变形后定理得证。 该定理保证了红黑树的高度是 [公式] 的。 插入 首先以普通的二叉搜索树的方式插入节点 [公式]，并将其颜色设为红色。然后调整树的结构，使其满足红黑树的性质。 记 [公式] 的父节点为 [公式]，祖父节点为 [公式]，祖父节点的另一个子节点（叔节点）为 [公式]。 如果 [公式] 为黑色，则无需任何调整；否则，[公式] 为红色，分以下三种情况讨论。 情况 1 [公式] 为红色，则 [公式] 一定是黑色。无论 [公式] 是 [公式] 的左节点还是右节点，只要将 [公式] 的颜色传递给 [公式] 和 [公式] 即可。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"调整后\">调整后 [公式] 为 [公式] 右节点的情况同理。 调整完成后，将 [公式] 作为新的 [公式] 继续向上调整。 情况 2 [公式] 为黑色，[公式] 为 [公式] 的左节点，此时 [公式] 一定是黑色。 情况 2 分为两步完成，第一步调整颜色，第二步在 [公式] 上进行 Right-Rotation。这样调整出来的树仍然满足红黑树的性质。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"颜色调整\">颜色调整 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"Right-Rotation\">Right-Rotation 对称情况同理。 调整完成后，将 [公式] 作为新的 [公式] 继续向上调整。 情况 3 [公式] 为黑色，[公式] 为 [公式] 的右节点。在 [公式] 上进行 Left-Rotation，将 [公式] 作为新的 [公式]，转为情况 2 处理。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑈 𝑧 \"} alt=\"Left-Rotation\">Left-Rotation 代码实现 调整的伪代码实现如下： 插入调整 } expand>\n[公式] 删除 TBD.","link":"/note/cs/ads/red-black-tree","is_index":false},{"title":"Skew Heaps","content":"TBD","link":"/note/cs/ads/skew-heaps","is_index":false},{"title":"Splay Tree","content":"在二叉搜索树的基础上，每次对节点的操作（查询、插入、删除）时，通过一些类似 AVL Tree 的旋转操作 将该节点移动到根节点 。 Splay Tree 的单次操作并不能达到 [公式] 的时间复杂度（在某些情况下甚至是 [公式] 的）。但可以证明，在任何连续的 [公式] 次操作后，能够保证 [公式] 的时间复杂度（即 摊还时间复杂度 ， Amortized Time Bound ）。 假如访问了节点 [公式]（在查询、插入后，删除前）： 如果 [公式] 是根节点，不进行任何操作； 如果 [公式] 的父节点是根节点，对 [公式] 进行一次 Single Rotation （即 AVL Tree 的 LL- 或 RR-Rotation，或称 Zig 操作），使得 [公式] 移动到根节点； 否则，记 [公式] 的父节点为 [公式]，祖父节点为 [公式]，分如下两种情况讨论。 Zig-Zag Zig-Zag 分为左右对称的两种情况，都是通过 Double Rotation （LR- 或 RL-Rotation）解决，下面以其中一种情况为例。 对于如下左图，通过在 [公式]、[公式]、[公式] 上进行 LR-Rotation 操作，从而把 [公式] 移动到根节点（如右图）。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"进行 Double Rotation 之后\">进行 Double Rotation 之后 Zig-Zig 这种情况是通过两次 Single Rotation 解决的，但是需要注意 旋转的顺序 ：从上往下先对 [公式] 进行一次旋转，再对 [公式] 旋转。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"进行两次 Single Rotation 之后\">进行两次 Single Rotation 之后 复杂度证明 见 摊还分析 。","link":"/note/cs/ads/splay-tree","is_index":false},{"title":"计算机科学","content":"","link":"/note/cs","is_index":true},{"title":"C Language Cheatsheet","content":"Format String The syntax of a format placeholder is % [ parameter ] [ flags ] [ width ] [ . precision ] [ length ] type\\n \"}> * Square brackets indicate optional parts of the placeholder. Type Type Description {\"%\"} Prints {\"%\"} . {\"d\"} Decimal {\"signed int\"} . {\"u\"} Decimal {\"unsigned int\"} . {\"o\"} Octal {\"unsigned int\"} . {\"x\"} , {\"X\"} Hexadecimal {\"unsigned int\"} . {\"x\"} for lower-case and {\"X\"} for upper-case. {\"f\"} Float-point types in fixed-point notation. {\"e\"} , {\"E\"} Float-point types in exponential notation: {\"d.ddde±dd\"} . {\"e\"} for lower-case “e” and {\"E\"} for upper-case. {\"g\"} , {\"G\"} Float-point types in either fixed-point or exponential notation, whichever is more appropriate for its magnitude. {\"g\"} for lower-case and {\"G\"} for upper-case. {\"a\"} , {\"A\"} Float-point in hexadecimal notation, starting with {\"0x\"} or {\"0X\"} . {\"a\"} for lower-case and {\"A\"} for upper-case. {\"s\"} {\"null\"} -terminated string. {\"c\"} {\"char\"} . {\"p\"} {\"void*\"} in an implementation-defined format. {\"n\"} Print nothing, but writes the number of characters written so far into an integer pointer parameter. Examples: printf ( \\\"%%\\\" ) ; // % \\n printf ( \\\"%d\\\" , 123 ) ; // 123 \\n printf ( \\\"%d\\\" , - 123 ) ; // -123 \\n printf ( \\\"%u\\\" , 123 ) ; // 123 \\n printf ( \\\"%u\\\" , - 123 ) ; // 4294967173 \\n printf ( \\\"%o\\\" , 123 ) ; // 173 \\n printf ( \\\"%x\\\" , 123 ) ; // 7b \\n printf ( \\\"%X\\\" , 123 ) ; // 7B \\n printf ( \\\"%f\\\" , 123.456 ) ; // 123.456000 \\n printf ( \\\"%e\\\" , 123.456 ) ; // 1.234560e+02 \\n printf ( \\\"%E\\\" , 123.456 ) ; // 1.234560E+02 \\n printf ( \\\"%g\\\" , 123.456 ) ; // 123.456 \\n printf ( \\\"%G\\\" , 123.456 ) ; // 123.456 \\n printf ( \\\"%g\\\" , 123456789.123 ) ; // 1.23457e+08 \\n printf ( \\\"%G\\\" , 123456789.123 ) ; // 1.23457E+08 \\n printf ( \\\"%a\\\" , 123.456 ) ; // 0x1.edd2f1a9fbe77p+6 \\n printf ( \\\"%A\\\" , 123.456 ) ; // 0X1.EDD2F1A9FBE77P+6 \\n printf ( \\\"%s\\\" , \\\"Hello\\\" ) ; // Hello \\n printf ( \\\"%c\\\" , 'H' ) ; // H \\n\\n int a = 123 ; \\n printf ( \\\"%p\\\" , & a ) ; // 0x16d79b3d8 \\n\\n int n ; \\n printf ( \\\"Hello%n\\\" , & n ) ; // Hello \\n printf ( \\\"%d\\\" , n ) ; // 5 \\n \"}> Others For further information, refer to Wikipedia . Here are some common examples: printf ( \\\"[%5d]\\\" , 123 ) ; // [  123] \\n printf ( \\\"[%-5d]\\\" , 123 ) ; // [123  ] \\n printf ( \\\"[%05d]\\\" , 123 ) ; // [00123] \\n printf ( \\\"[%+5d]\\\" , 123 ) ; // [ +123] \\n printf ( \\\"[%*d]\\\" , 5 , 123 ) ; // [  123] (dynamic width) \\n printf ( \\\"[%.1f]\\\" , 123.456 ) ; // [123.5] \\n printf ( \\\"[%10f]\\\" , 123.456 ) ; // [123.456000] (10 characters in total) \\n printf ( \\\"[%10.5f]\\\" , 123.456 ) ; // [ 123.45600] (5 precision, 10 characters) \\n printf ( \\\"[%010.5f]\\\" , 123.456 ) ; // [0123.45600] (5 precision, 10 characters) \\n \"}>","link":"/note/cs/others/c-language-cheatsheet","is_index":false},{"title":"其他","content":"","link":"/note/cs/others","is_index":true},{"title":"Manuals & Standards","content":"Semantic Versioning Refer to : Semantic Versioning . Given a version number {\"MAJOR.MINOR.PATCH\"} , increment the: {\"MAJOR\"} version when you make incompatible API changes. {\"MINOR\"} version when you add functionality in a backward compatible manner. {\"PATCH\"} version when you make backward compatible bug fixes. Conventional Commits Refer to : Conventional Commits / Angular Convention . Structure of the commit message: <type>[optional scope]: <description>\\n\\n[optional body]\\n\\n[optional footer(s)]\\n \"}> {\"fix\"} : correlates with {\"PATCH\"} in SemVer. {\"feat\"} : correlates with {\"MINOR\"} in SemVer. {\"BREAKING CHANGE\"} : a commit that has a footer {\"BREAKING CHANGE\"} , or appends a {\"!\"} after the type/scope, correlating with {\"MAJOR\"} in SemVer. {\" \"} : {\"build\"} , {\"chore\"} , {\"ci\"} , {\"docs\"} , {\"style\"} , {\"refactor\"} , {\"perf\"} , {\"test\"} , etc. {\" \"} : use the imperative, present tense: “change” not “changed” nor “changes”. don’t capitalize the first letter. no dot ( {\".\"} ) at the end. Example: chore!: drop support for Node 6\\n\\nBREAKING CHANGE: use JavaScript features not available in Node 6.\\n \"}>","link":"/note/cs/others/manuals-standards","is_index":false},{"title":"MIT Missing Semester","content":"📖 COURSE-STARTED-AT : 2023-11-5 🔮 COURSE-FINISHED-AT : 2023-11-11 🔗 COURSE-SITE : missing.csail.mit.edu MIT Missing Semester is a course that teaches the untaught parts of computer science. Classes teach you all about advanced topics within CS, from operating systems to machine learning, but there’s one critical subject that’s rarely covered, and is instead left to students to figure out on their own: proficiency with their tools . We’ll teach you how to master the command-line, use a powerful text editor, use fancy features of version control systems, and much more! ——MIT Missing Semester For the parts I’m already familiar with, I skip them. Shell Scripting Variables To define a variable : use {\"foo=bar\"} instead of {\"foo = bar\"} . The latter tries to run a command named {\"foo\"} with arguments {\"=\"} and {\"bar\"} . To use a variable : use {\"$foo\"} . Special variables : (take {\"./script.sh foo bar\"} as an example) {\"$0\"} : {\"./script.sh\"} , name of the script. {\"$1\"} to {\"$9\"} : {\"foo\"} to {\"bar\"} , arguments to the script. {\"$@\"} : {\"foo bar\"} , all arguments. {\"$#\"} : {\"2\"} , number of arguments. {\"$?\"} : Return code of the previous command. {\"$$\"} : PID of the current script. {\"$_\"} : Last argument of the last command. Arithmetic : use {\"((x + y))\"} to do arithmetic. Use {\"$((x + y))\"} to use the result of the arithmetic. Comparisons like {\"((x >= y))\"} are also supported. Operators Operator {\"||\"} , {\"&&\"} and {\";\"} : {\"foo || bar\"} means “run {\"foo\"} , if it fails, run {\"bar\"} ”. {\"foo && bar\"} means “run {\"foo\"} , if it succeeds, run {\"bar\"} ”. {\"foo ; bar\"} means “run {\"foo\"} , then run {\"bar\"} ”. Example: false || echo \\\"Oops, fail\\\" # Oops, fail \\n true || echo \\\"Will not be printed\\\" # \\n true && echo \\\"Things went well\\\" # Things went well \\n false && echo \\\"Will not be printed\\\" # \\n true ; echo \\\"This will always run\\\" # This will always run \\n false ; echo \\\"This will always run\\\" # This will always run \\n \"}> Command substitution : use {\"$(foo)\"} to run {\"foo\"} and use its output as a string. Example: {\"for file in $(ls)\"} iterates over all files. Process substitution : {\" will run {\"foo\"} and place the output in a temporary file and substitute the {\" with that file’s name. Example: {\"diff compares the files of directory {\"foo\"} and {\"bar\"} . Redirection Input : use {\" to redirect input from a file. Output : use {\">\"} to redirect output to a file. Use {\">>\"} to append to a file. Error : use {\"2>\"} to redirect error to a file. Both output and error : use {\"&>\"} to redirect both output and error to a file. Both input and output : use {\"<>\"} to redirect both input and output to a file. Discard : redirect to {\"/dev/null\"} to discard output/error/input. Pipe : use {\"|\"} to pipe the output of a command to the input of another command. Control Flow {\"If\"} : use {\"if foo; then bar; fi\"} to run {\"bar\"} if {\"foo\"} succeeds. {\"foo\"} can be any command or a test. Refer to {\"man test\"} for more information about tests. Here are some simple examples: {\"if [[ -d foo ]];\"} : if {\"foo\"} is a directory. {\"if [[ -f foo ]];\"} : if {\"foo\"} is a file. {\"if [[ $foo -ne 0 ]];\"} : if {\"foo\"} is not equal to {\"0\"} . {\"if [[ $foo -gt 0 ]];\"} : if {\"foo\"} is greater than {\"0\"} . The {\"[[ ]]\"} notation is syntactic sugar for the {\"test\"} command. The following two lines are equivalent: if [ [ -d foo ] ] ; then \\n if test -d foo ; then \\n \"}> {\"[[ ]]\"} notation provides more features than {\"test\"} . For example, {\"[[ ]]\"} supports {\"&&\"} and {\"||\"} operators, while {\"test\"} does not. {\"For\"} , {\"While\"} and {\"Until\"} : # Run baz for each foo in bar \\n for foo in bar ; do baz ; done \\n\\n # e.g. Print all files in the current directory \\n for file in $( ls ) ; do echo $file ; done \\n\\n # Run bar while foo succeeds \\n while foo ; do bar ; done \\n\\n # e.g. Print \\\"Hello\\\" forever \\n while true ; do echo \\\"Hello\\\" ; done \\n\\n # Run bar until foo succeeds \\n until foo ; do bar ; done \\n\\n # e.g. Print \\\"Hello\\\" forever \\n until false ; do echo \\\"Hello\\\" ; done \\n \"}> Case : see the example: case $fruit in \\n    apple ) \\n echo \\\"It's an apple.\\\" \\n ; ; \\n    banana ) \\n echo \\\"It's a banana.\\\" \\n ; ; \\n    orange | lemon ) # \\\"|\\\" means \\\"or\\\" \\n echo \\\"It's an orange or a lemon.\\\" \\n ; ; \\n    * ) \\n echo \\\"It's an unknown fruit.\\\" \\n ; ; \\n esac \\n \"}> Functions : use {\"foo() { bar; }\"} to define a function named {\"foo\"} that runs {\"bar\"} . Example: multiply ( ) { \\n result = $(( $ 1 * $ 2 )) \\n echo \\\"The result of multiplication is: $result \\\" \\n } \\n\\n # Call the function \\nmultiply 5 3 \\n \"}> Others Shebang : use {\"#!/bin/bash\"} to specify the interpreter of the script. The shebang must be the first line of the script. You can also choose python as the interpreter, e.g. {\"#!/usr/bin/env python\"} . Exit code : use {\"exit 0\"} to exit with code {\"0\"} . Use {\"exit\"} to exit with the return code of the last command. Homework Write a command or script to recursively find the most recently modified file in a directory. More generally, can you list all files by recency? Here is my implementation of the first part of the homework. __check_modified ( ) { \\n local file \\n file = $( ls -t \\\" $1 \\\" | head -n1 ) \\n\\n while [ [ -d \\\" $1 / $file \\\" ] ] ; do \\n file = $( ls -t \\\" $1 / $file \\\" | head -n1 ) \\n done \\n\\n echo \\\" $1 / $file \\\" \\n } \\n\\n__check_modified \\\" $1 \\\" \\n \"}> Data Wrangling I don’t know how to document this part, so I just note down some useful tools. {\"grep\"} : search for a pattern in a file. {\"sed\"} : stream editor. {\"awk\"} : pattern scanning and processing language. {\"sort\"} : sort lines of text files. {\"uniq\"} : report or omit repeated lines. {\"paste\"} : merge lines of files. {\"wc\"} : print newline, word, and byte counts for each file. {\"tee\"} : read from standard input and write to standard output and files. {\"tr\"} : translate or delete characters. {\"tac\"} : reverse {\"cat\"} . {\"less\"} : open a file for interactive reading. {\"head\"} : output the first part of files. {\"tail\"} : output the last part of files. {\"xargs\"} : build and execute command lines from standard input. {\"bc\"} : arbitrary precision calculator language. {\"jq\"} : command-line JSON processor. {\"pup\"} : command line tool for processing HTML. One more thing : Learning Regex can be incredibly useful. It’s definitely worth investing time in! Command-line Environment Job Control When pressed {\"Ctrl-C\"} , the shell delivers a SIGINT SIGnal to the process, which by default INTerrupts the process. This python program captures SIGINT and ignores it: import signal , time\\n\\n def handler ( signum , time ) : \\n print ( \\\"\\\\nI got a SIGINT, but I am not stopping\\\" ) \\n\\nsignal . signal ( signal . SIGINT , handler ) \\n\\n # This program is a simple counter \\ni = 0 \\n while True : \\n    time . sleep ( .1 ) \\n print ( \\\"\\\\r{}\\\" . format ( i ) , end = \\\"\\\" ) \\n    i += 1 \\n \"}> When we run this program and press {\"Ctrl-C\"} , the program will continue to run. To stop it, we need to send a SIGQUIT signal to it, by typing {\"Ctrl-\\\\\"} . $ python sigint.py\\n 16 ^C\\nI got a SIGINT, but I am not stopping\\n 25 ^C\\nI got a SIGINT, but I am not stopping\\n 45 ^ \\\\ [ 1 ] 54634 quit       python sigint.py\\n \"}> Note that SIGINT and SIGQUIT can both be captured by the program. However, SIGTERM cannot. It is a more graceful way to TERMinate the process. To send the signal we can use {\"kill -TERM \"} or {\"kill \"} for short. {\"Ctrl-Z\"} is used to suspend a process. It sends a SIGTSTP signal, short for “terminal stop”. When a process is suspended, it pauses. Command {\"jobs\"} lists the unfinished jobs associated with the current terminal session. For example, if I suspended the {\"sigint.py\"} program above: $ python sigint.py\\n 25 ^Z\\n [ 1 ] + 56852 suspended  python sigint.py\\n$ jobs \\n [ 1 ] + suspended  python sigint.py\\n \"}> Then we can use {\"fg\"} to bring the job to the foreground, and {\"bg\"} to the background. $ fg %1 # %1 means it is the first job \\n [ 1 ] + 56852 continued  python sigint.py\\n 75 # Number counting continues \\n \"}> By using the {\"&\"} suffix, a command runs in the background but still prints to the terminal. To background a program we can use {\"Ctrl-Z\"} and {\"bg\"} , but note that the process will die if you close the terminal. To prevent this, we can use {\"nohup\"} to run the program in the background, it sets the process to ignores SIGHUP signal, which is sent to a process when the terminal session ends. $ nohup python sigint.py & \\n \"}> To get a comprehensive list of signals, check {\"man signal\"} . Terminal Multiplexers Refer to Tmux . Here is a tutorial: A Quick and Easy Guide to tmux . Version Control (Git) Here I list some useful commands that I’m not familiar with. I won’t dig into that too much. $ git log --all --graph --decorate \\n$ git clone --shallow \\n$ git fetch\\n$ git stash\\n$ git stash pop\\n \"}> Metaprogramming Here is an example of a simple Makefile that compiles a LaTeX document. paper.pdf : paper.tex plot-data.png\\n\tpdflatex paper.tex\\n\\n plot-%.png : %.dat plot.py\\n\t./plot.py -i $*.dat -o $@ \\n \"}> Security and Cryptography Cryptographic hash function Cryptographic hash functions map an arbitrary length input to a fixed-length output. The general model is hash(value: array<byte>) -> vector<byte, N>  (for some fixed N)\\n \"}> It has the following properties: Deterministic : the same input maps to the same output. Non-invertible : it is hard to find an input m such that {\"hash(m) = h\"} for some desired output {\"h\"} . Target collision resistant : given an input {\"m1\"} , it’s hard to find a different input {\"m2\"} such that {\"hash(m1) = hash(m2)\"} . Collision resistant : it’s hard to find two inputs {\"m1\"} and {\"m2\"} such that {\"hash(m1) = hash(m2)\"} (this is a strictly stronger property than target collision resistance). Note that it is hard to find a collision, but it is not completely impossible . This is why each cryptographic hash function has a lifespan . A widely used cryptographic hash function is SHA-1 . For example, Git uses SHA-1 to identify commits. But it is not secure anymore . To generate an SHA-1 hash, we can use the {\"shasum\"} command on macOS. $ echo \\\"hello, world\\\" | shasum -a 1 \\ncd50d19784897085a8d0e3e413f8612b097c03f1  -\\n \"}> Imagine we’re playing a number-guessing game. I’ve thought of a random number, and you’re trying to guess it. You need to share your guess before I reveal if it’s correct. Now, to ensure I don’t cheat by altering the number in my mind, we can employ a cryptographic hash function. Before you make your guess, I’ll share the hash of my number. After the game, you can verify that I haven’t tampered with the chosen number by checking the hash of your guessed number. Key derivation function Key derivation functions , or KDFs , share similarities with cryptographic hash functions, but they are specifically designed for deriving secret keys from a given input, typically a password or a low-entropy key. KDFs are intentionally designed to operate at a slow pace, making it time-consuming to brute-force the password. Applications : Producing keys from passphrases for use in other cryptographic algorithms (e.g. symmetric cryptography). Storing login credentials. Storing plaintext passwords is bad; the right approach is to generate and store a random salt {\"salt = random()\"} for each user, store {\"KDF(password + salt)\"} , and verify login attempts by re-computing the KDF given the entered password and the stored salt. Symmetric cryptography Symmetric cryptography is used to encrypt and decrypt data. It uses a secret key to encrypt and decrypt data. The same key is used for both encryption and decryption. The model is keygen() -> key  (this function is randomized)\\n\\nencrypt(plaintext: array<byte>, key) -> array<byte>  (the ciphertext)\\ndecrypt(ciphertext: array<byte>, key) -> array<byte>  (the plaintext)\\n \"}> An example of a symmetric cryptosystem in wide use today is AES. Asymmetric cryptography Except for encrypting and decrypting data, asymmetric cryptography can also be used to sign and verify data. It uses a public key and a private key . The public key is used to encrypt data and verify signatures, while the private key is used to decrypt data and sign data. The model is keygen() -> (public-key, private-key)  (this function is randomized)\\n\\nencrypt(plaintext: array<byte>, public-key) -> array<byte>  (the ciphertext)\\ndecrypt(ciphertext: array<byte>, private-key) -> array<byte>  (the plaintext)\\n\\nsign(message: array<byte>, private-key) -> array<byte>  (the signature)\\nverify(message: array<byte>, signature: array<byte>, public-key) -> bool  (whether or not the signature is valid)\\n \"}> As its name suggests, public key can be made public. Anyone can use the public key to encrypt data for you , but only you, with the corresponding private key, can decrypt it. That’s how private messaging apps like Telegram works. On the flip side, you can sign data using your private key. Others can then verify the signature using your public key. This mechanism is exemplified in practices such as verifying commits in Git through digital signatures.","link":"/note/cs/others/mit-missing-semester","is_index":false},{"title":"笔记","content":"","link":"/note","is_index":true},{"title":"Français","content":"字母表 字母 音标 字母 音标 Aa {\"[a]\"} Nn {\"[ɛn]\"} Bb {\"[be]\"} Oo {\"[o]\"} Cc {\"[se]\"} Pp {\"[pe]\"} Dd {\"[de]\"} Qq {\"[ky]\"} Ee {\"[ə]\"} Rr {\"[ɛr]\"} Ff {\"[ɛf]\"} Ss {\"[ɛs]\"} Gg {\"[ʒe]\"} Tt {\"[te]\"} Hh {\"[aʃ]\"} Uu {\"[y]\"} Ii {\"[i]\"} Vv {\"[ve]\"} Jj {\"[ʒi]\"} Ww {\"[dubləve]\"} Kk {\"[ka]\"} Xx {\"[iks]\"} Ll {\"[ɛl]\"} Yy {\"[iɡrɛk]\"} Mm {\"[ɛm]\"} Zz {\"[zɛd]\"} 音素 元音 ： {\"[a] [ɔ] [œ] [ɛ] [o] [ø] [e] [ə] [u] [y] [i] [ɑ̃] [ɛ̃] [œ̃] [ɔ̃]\"} 辅音 ： {\"[p] [b] [t] [d] [f] [v] [k] [g] [s] [z] [ʃ] [ʒ] [m] [n] [ɲ] [l] [r]\"} 半元音 ： {\"[j] [ч] [w]\"} 发音规则 元音 音素 读音规则 例词 {\"[a]\"} a, à, â sa, là, âme {\"[ɛ]\"} è, ê mère, fête ai, ei fait, veine e 在闭音节中 sel e 在两个相同的辅音字母前 cette et 在词末 filet {\"[i]\"} i, î, ï mie, île, maïs y style {\"[e]\"} é bébé es 在单音节词中 des er, ez 在词末 fêter {\"[fɛte]\"} , aidez {\"[ɛde]\"} {\"[y]\"} u, û tu {\"[ty]\"} , dû, culture {\"[kyltyr]\"} {\"[ə]\"} e 在词首开音节中 chemise {\"ʃəmiz\"} e 在单音节词中 ce {\"[sə]\"} e 在“辅辅 e 辅元”中 vendredi {\"[ã]\"} am, an 后无 m, n 或元音字母 lampe, dans em, en 后无 m, n 或元音字母 temps {\"[tã]\"} , vent {\"[vã]\"} , an {\"[ã]\"} 辅音 音素 读音规则 例词 {\"[s]\"} s tasse ç ça, français c 在元音字母 e, i, y 前 face, cidre, cycle {\"[t]\"} t, th ta, thé {\"[d]\"} d date {\"[f]\"} f fade ph phare {\"[v]\"} v vie {\"[m]\"} m mais {\"[ʃ]\"} ch chaise {\"[ʃɛz]\"} , chine {\"[ʃin]\"} {\"[ʒ]\"} j jupe {\"[ʒyp]\"} , déjà {\"[deʒa]\"} g 在元音字母 e, i, y 前 âge, gile, gymnase {\"[k]\"} k kaki c 在元音字母 a, o, u 或辅音字母前 car, code {\"[kɔd]\"} , cube, classe c 在词尾 lac {\"lak\"} qu quel {\"[kɛl]\"} {\"[g]\"} g 在元音字母 a, o, u 或辅音字母前 gare, gomme, légume, glace gu 在元音字母 e, i, y 前 guerre, guide {\"[r]\"} r rire, revue {\"[rəvy]\"} {\"[z]\"} z zèle s 在两个元音字母之间 Asie","link":"/note/misc/french","is_index":false},{"title":"杂项","content":"","link":"/note/misc","is_index":true},{"title":"自定义语法","content":"数学公式 利用 KaTeX 渲染数学公式。 行内公式 ... $ < 公式内容 > $ ...\\n \"}> 效果 可以不难推得 [公式]。 [公式] 这个名字来源于单词 Decade：[公式]。 源码 可以不难推得 $\\\\varphi(n):=n\\\\prod_{p\\\\mid n}(1-\\\\frac{1}{p})$。\\n\\n$\\\\mathfrak{Xecades}$ 这个名字来源于单词 Decade：$\\\\text{10 Decades}\\\\rightarrow \\\\text{X Decades}\\\\rightarrow \\\\text{Xecades}$。\\n \"}> 行间公式 $$\\n < 公式内容 > \\n$$\\n \"}> 效果 [公式] 源码 $$\\n\\\\begin{aligned}\\n&\\\\Bigl(f*g\\\\Bigr)(6) \\\\\\\\\\n=&\\\\sum_{d\\\\mid 6}f(d)g\\\\biggl(\\\\dfrac{6}{d}\\\\biggr) \\\\\\\\\\n=&f(1)g(6)+f(2)g(3)+f(3)g(2)+f(6)g(1)\\n\\\\end{aligned}\\n$$\\n \"}> Icon 使用 FontAwesome 加载 SVG 图标。 ... : < icon > : ...\\n \"}> 效果 The magic spell will lead you to the treasure . 源码 The * magic spell * :arrow-up: :arrow-up: :arrow-down: :arrow-down: :arrow-left: :arrow-right: :arrow-left: :arrow-right: :a: :b: :a: :b: will lead you to the treasure :sack-dollar:.\\n \"}> 引言 适合用于展示名言、引用等。 ::quote\\n < 引言内容 > \\n::\\n \"}> 效果 Two roads diverged in a wood, and I— I took the one less traveled by , And that has made all the difference. —Robert Frost 源码 :::quote\\nTwo roads diverged in a wood, and I—\\\\\\nI took * the one less traveled by * ,\\\\\\nAnd that has made all the difference.\\\\\\n < right > —Robert Frost </ right > \\n:::\\n \"}> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. [公式] Note 功能上类似于 MkDocs Material 的 Admonitions ，用于提供额外信息。 ::note{[default] | primary | success | info | warning | danger}\\n < Note 内容 > \\n::\\n \"}> 效果 这里是 {\"note.default\"} 的内容 源码 :::note\\n这里是 `note.default` 的内容\\n:::\\n \"}> 效果 [公式] 源码 :::note{danger}\\n$\\\\text{P} \\\\neq \\\\text{NP}$\\n:::\\n \"}> 这里是 {\"note.primary\"} 的内容 这里是 {\"note.success\"} 的内容 这里是 {\"note.info\"} 的内容 这里是 {\"note.warning\"} 的内容 这里是 {\"note.danger\"} 的内容 Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 折叠面板 ::fold{title=\\\"[标题]\\\" [ expand ] [ default ] | primary | success | info | warning | danger}\\n < 折叠内容 > \\n::\\n \"}> 效果 默认展开的 {\"default\"} 折叠面板 } expand>这里是 {\"fold.default\"} 的内容 源码 :::fold{title=\\\"默认展开的 `default` 折叠面板\\\" expand}\\n这里是 `fold.default` 的内容\\n:::\\n \"}> {\"primary\"} 折叠面板 } type=\"primary\">这里是 {\"fold.primary\"} 的内容 {\"success\"} 折叠面板 } type=\"success\">这里是 {\"fold.success\"} 的内容 {\"info\"} 折叠面板 } type=\"info\">这里是 {\"fold.info\"} 的内容 {\"warning\"} 折叠面板 } type=\"warning\">这里是 {\"fold.warning\"} 的内容 {\"danger\"} 折叠面板 } type=\"danger\">这里是 {\"fold.danger\"} 的内容 标题是支持 [公式] 的 } expand type=\"success\"> 折叠面板也支持 [公式]！ [公式] Lorem } type=\"danger\"> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Veniam irure ipsum dolore dolore Lorem voluptate adipisicing eiusmod minim. Eu incididunt enim irure nisi. Amet eu nostrud irure Lorem mollit eu ipsum excepteur cillum irure in sint reprehenderit deserunt. Occaecat adipisicing culpa excepteur magna id dolor exercitation ut ea dolor ut veniam est eiusmod. Consequat qui ut labore dolor ut. Ipsum ullamco commodo veniam occaecat fugiat sint consectetur nisi deserunt sunt ullamco et veniam. Do commodo mollit voluptate veniam ipsum irure dolore nisi. 这个折叠面板没有标题 这个折叠面板的标题真的真的真的真的真的真的真的真的真的真的真的真的非常的长，而且里面还有 {\"code\"} 块 }> print ( \\\"Hello World\\\" ) \\n \"}> 链接卡片 ::linkcard{href=\\\" < 链接地址 > \\\"}\\n < 链接名称 > \\n::\\n \"}> 效果 Xecades 的博客 源码 :::linkcard{href=\\\"https://blog.xecades.xyz/\\\"}\\nXecades 的博客\\n:::\\n \"}> [公式] 的 GitHub 仓库 Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Typst 渲染 基于 Typst.ts 实现 Typst 的渲染。 ```typst [标题]\\n<Typst 代码>\\n```\\n \"}> 效果 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 15 13 12 14 17 16 18 18 \"} alt=\"一棵来自 Typst 的树\">一棵来自 Typst 的树 源码 ``` typst 一棵来自 ***Typst*** 的树 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([15], ([13], [12], [14]), ([17], [16], ([18], [], [18])))\\n    )\\n}) \\n ``` \\n \"}> 选项卡 ::tab\\n # <选项卡 1> \\n\\n < 选项卡 1 内容 > \\n\\n # <选项卡 2> \\n\\n < 选项卡 2 内容 > \\n\\n[...]\\n::\\n \"}> 选项卡 1 这里是「 选项卡 1 」 的内容 选项卡 2 这里是「 选项卡 2 」 的内容 [公式] 公式 选项卡也是支持 [公式] 的！ [公式] Lorem Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 一个名字很长很长很长很长很长很长的选项卡（而且名字里面还有 {\"code\"} ） print ( \\\"Hello World\\\" ) \\n \"}> 源码 :::tab\\n # 选项卡 1 \\n\\n这里是「 ** 选项卡 1 ** 」 的内容\\n\\n # 选项卡 2 \\n\\n这里是「 ** 选项卡 2 ** 」 的内容\\n\\n # $\\\\LaTeX$ 公式 \\n\\n选项卡也是支持 $\\\\LaTeX$ 的！\\n\\n$$\\n\\\\begin{aligned}\\n&\\\\Bigl(f*g\\\\Bigr)(6) \\\\\\\\\\n=&\\\\sum_{d\\\\mid 6}f(d)g\\\\biggl(\\\\dfrac{6}{d}\\\\biggr) \\\\\\\\\\n=&f(1)g(6)+f(2)g(3)+f(3)g(2)+f(6)g(1)\\n\\\\end{aligned}\\n$$\\n\\n # Lorem \\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\n\\n # 一个名字很长很长很长很长很长很长的选项卡（而且名字里面还有 `code`） \\n\\n ``` python \\n print ( \\\"Hello World\\\" ) \\n ``` \\n:::\\n \"}> 唯一一个 Tab！ 这个选项卡只有这一个 Tab Grid ::grid\\n:sep{width=\\\" < 宽度 > \\\"}\\n\\n < 内容 1 > \\n\\n:sep{width=\\\" < 宽度 > \\\"}\\n\\n < 内容 2 > \\n\\n[...]\\n::\\n \"}> 效果 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 20 16 13 18 25 21 28 \"} alt=\"二叉搜索树 例 1\"> 二叉搜索树 例 1 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 10 5 2 7 15 \"} alt=\"二叉搜索树 例 2\"> 二叉搜索树 例 2 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 15 13 12 14 17 16 18 18 \"} alt=\"二叉搜索树 例 3\"> 二叉搜索树 例 3 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 16 10 7 1 15 19 17 18 20 \"} alt=\"二叉搜索树 例 4\"> 二叉搜索树 例 4 源码 :::grid\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 1 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([20], ([16], [13], [18]), ([25], [21], [28]))\\n    )\\n}) \\n ``` \\n\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 2 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([10], ([5], [2], [7]), [15])\\n    )\\n}) \\n ``` \\n\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 3 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([15], ([13], [12], [14]), ([17], [16], ([18], [], [18])))\\n    )\\n}) \\n ``` \\n\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 4 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([16], ([10], ([7], [1], []), [15]), ([19], ([17], [], [18]), [20]))\\n    )\\n}) \\n ``` \\n\\n:::\\n \"}>","link":"/note/misc/test/customToken","is_index":false},{"title":"测试","content":"","link":"/note/misc/test","is_index":true},{"title":"LaTeX 测试","content":"狄利克雷卷积 （Dirichlet Convolution）在解析数论中是一个非常重要的工具. 使用狄利克雷卷积可以很方便地推出 莫比乌斯反演 （Möbius Inversion）相关重要函数和公式，它在信息学竞赛和解析数论中至关重要. 很多初学者不能真正地理解莫比乌斯反演，或者说即使能使用最终的公式，也难以理清楚它是怎么推导的. 本文中，我将尝试使用一种新的方式讲解狄利克雷卷积和莫比乌斯反演，希望能对大家有所帮助. 文中的引语（浅色文字）是可选内容，为正文的补充或提示. 阅读时，你可以选择跳过这部分文字，而不会影响内容连贯性. 什么是狄利克雷卷积 狄利克雷卷积是定义在 数论函数 间的二元运算. 所谓 数论函数 ，是指定义域为 [公式]（ 自然数 ），值域为 [公式]（ 复数 ） 的一类函数，每个数论函数可以视为复数的序列. 它最常见的定义式为： [公式] 这里提醒一个很明显的事实：在这个定义式中，右式的函数 [公式] 和 [公式] 括号中的参数是可以调换的，即： [公式] 如果我们比较关注式子的对称性，下面有狄利克雷卷积的另一个定义式： [公式] 下面举一个例子，以方便理解： [公式] 在后面的文章中我们会反复应用这两个定义式. 为什么叫“狄利克雷卷积”呢？ 首先， 狄利克雷 （Gustav Lejeune Dirichlet）是 19 世纪德国的数学家，他是解析数论的创立者，是解析数论很多重要理论的提出者. 至于“卷”，可以理解为在二维平面上延伸的两个数论函数（一个沿 x 轴，一个沿 y 轴）像卷毛巾一样交叉结合起来. “积”这个字在定义式中的星号 [公式] 体现出来了，如果定义普通函数加法为数论函数间的“加”运算，那么这里的狄利克雷卷积就是数论函数的“乘”运算，这一点我会在后文再次提到. 本文要用到的数论函数 还记得到吗？数论函数都是 [公式] 类型的. 下面我来列举一些常用的数论函数. 初看时你可能会觉得这些定义没有什么用，但它们在狄利克雷卷积中大多是作为记号存在的. 单位函数 [公式] [公式] 幂函数 [公式] [公式] 特别地，有： 当 [公式] 时，为 恒等函数 [公式]，即 [公式]. 当 [公式] 时，为 常数函数 [公式]，即 [公式]. 这里的常数函数 [公式] 的函数名是 加粗了 的数字 [公式]，不要和 [公式] 弄混了.\n在某些场合，有人会用大写字母 [公式] 来代替 [公式]，以防混淆，这里还是使用 [公式]. 除数函数 [公式] 直观上理解，除数函数就是其所有因数的 [公式] 次方之和. [公式] 特别地，有： 当 [公式] 时，为 因数函数 [公式]，即 [公式]. 当 [公式] 时，为 个数函数 [公式]，即 [公式]. 从“因数函数”和“个数函数”这两个名字就可以看出来，[公式] 表示 [公式] 的因数之和，[公式] 表示 [公式] 的因数个数. 例如，[公式]，[公式]. 对于因数函数和个数函数，设 [公式]，其中 [公式]，可以得到这两个计算式（不是重点，证明从略）： [公式] 欧拉函数 [公式] 欧拉函数博大精深，这里只介绍一些内容. [公式] 表示小于 [公式] 的正整数中与 [公式] 互质的数的个数. 可以不难推知（证明从略）： [公式] 总共（提及的）有： 单位函数 [公式]、 幂函数 [公式]（含 恒等函数 [公式] 和 常数函数 [公式]）、 除数函数 [公式]（含 因数函数 [公式] 和 个数函数 [公式]）、 欧拉函数 [公式]. 上面提到的 所有 函数都是 积性函数 ，其中 单位函数 和 幂函数 是 完全积性函数 （证明从略）. 积性函数 是指对 所有互质的整数 [公式] 和 [公式] 都有 [公式] 的数论函数. 完全积性函数 是指对 所有整数 [公式] 和 [公式] 都有 [公式] 的数论函数. 在 [公式] 式中令 [公式]，得到 [公式]，这也是积性函数一重要特点. 狄利克雷卷积相关定理 读者不妨先不看证明，自己试着证一下. [1] 若 [公式]，[公式] 为积性函数，则 [公式] 也是积性函数. 设 [公式]（即 [公式] 和 [公式] 互质）则： [公式] 在将 [公式] 合并成 [公式] 的操作中，用到了由 [公式]、[公式] 互质推导出来的结论：[公式] 的因数唯一表示为 [公式] 的因数与 [公式] 的因数的乘积，因此 [公式] 和 [公式] 是完全等价的. [2] 狄利克雷卷积满足交换律，即 [公式]. [公式] 在 [公式] 中，我将 [公式] 和 [公式] 换了个位置（也就是 [公式] 写成 [公式]，[公式] 写成 [公式]. 实际上这不是必须的），然后把 [公式] 挪到了 [公式] 的前面. 这里我用的是第二个定义式，它的优点是对称性好，用来证明交换律很直观. [3] 狄利克雷卷积满足结合律，即 [公式]. [公式] 从 [公式] 开始，类似地也可以得到 [公式]，因此它们相等，结合律成立. [4] 狄利克雷卷积满足分配律，即 [公式]. [公式] 这里总结一下我们证了的式子： 若 [公式]，[公式] 为积性函数，则 [公式] 也是积性函数. 狄利克雷卷积满足 交换律 ，即 [公式]. 狄利克雷卷积满足 结合律 ，即 [公式]. 狄利克雷卷积满足 分配律 ，即 [公式]. 这些结论十分重要，后文中我可能会在不说明的情况下直接使用这些结论. 为什么是“积”？ 现在我们可以得出原因了，狄利克雷卷积满足 交换律 、 结合律 和 分配律 ，其运算法则和普通算数乘法完全类似（在小学的时候我们就已经学过乘法的三定律了）. 实际上，狄利克雷卷积和普通函数加法可以构成一个 阿贝尔环 ，你甚至可以在它的基础上构建以函数为自变量的多项式，并解它的根. 一些特殊的卷积 看到这里，前文提到的数论函数才能真正地起作用. [1] [公式] [公式] 在证明的过程中，我们发现：如果一个函数和 [公式] 作狄利克雷卷积，就相当于把其参数的所有因子枚举出来并代入原函数，然后求和. 也就是说： [公式] 无论是正向操作还是反向操作，这个式子都很重要. [2] [公式] 再提醒一下，[公式] 的定义是这样的： [公式] 首先有： [公式] 尝试对 [公式] 进行拆分，当 [公式] 时，有： [公式] 考虑更普遍的情况，当 [公式] 为任意正整数，分解 [公式]，因为 [公式] 是积性函数，所以： [公式] 综上，[公式]. [3] [公式] 这个证明相对更简单. [公式] 上面我们只列举出了三个常用的狄利克雷卷积结果，分别是： [公式]; [公式]; [公式]. 实际上，通过这几个运算我们可以得到更多的运算，例如： [公式] 单位元 乘法的 单位元 是指乘上它后值不改变的数（对狄利克雷卷积来说，是“函数”）. 例如，普通乘法的单位元是数字 [公式]，因为 [公式]. 因此，在狄利克雷卷积中，它的单位元 [公式] 就应该满足 [公式]. 我们注意到这样一个事实： [公式] 因此，狄利克雷卷积的单位元就是 单位函数 [公式]，它在狄利克雷卷积中的作用和 1 在普通乘法中的作用是类似的. 任何函数（ 包括 [公式] ）和 [公式] 进行狄利克雷卷积，都得到该函数本身. 还记得到吗？[公式] 的定义是这样的： [公式] 狄利克雷逆（Dirichlet Inverse） 我们可以把这里的“ 逆 ”和“ 逆元 ”作类比. 例如，在普通运算中，一个数的“逆元”就是这个数的倒数；在同余运算中，一个数的“逆元”在同个模的意义下，能使得它与这个数相乘的结果与 [公式] 同余. 分别而言，如果我们规定 [公式] 的逆元是 [公式]（这个符号是作为整体引入的， 大多数情况下不能简单地理解为 [公式] ），那么就有这样两个式子： [公式] 数字 [公式] 是两种运算中的单位元，所以说，逆元在类似乘法的运算中起着“倒数”的地位. 在狄利克雷卷积中，单位元是 [公式]，我们定义狄利克雷逆如下： [公式] 函数 [公式] 就被称为 [公式] 的 狄利克雷逆 . 对于狄利克雷逆公式的推导，可以使用 合情推理 的方法（列出 [公式]，然后找规律），得到狄利克雷逆的计算式： [公式] 这个式子我们不推导，仅证明它是成立的: 当 [公式] 时，[公式]. 当 [公式] 时， [公式] 也就是说，[公式]. 因此这个计算式是成立的. 值得注意的是，狄利克雷逆的计算式中包含了自身，也就是说它是个 递归形式的定义 . 若将其展开，则过于复杂，（一般）没有实际意义. 一个数论函数 [公式] 存在狄利克雷逆的 充要条件 是 [公式]，在狄利克雷逆的推导过程中，我们知道 [公式] 的逆是唯一的 . 需要指出， 积性函数一定有狄利克雷逆，且它也是积性函数 ，该证明从略（请参见芝加哥大学 Mark Schachner 的 Paper ）. 当 [公式] 且 [公式] 时，有 [公式]，证明如下： [公式] 由狄利克雷逆的唯一性，[公式] 的狄利克雷逆是唯一的，所以 [公式]. 莫比乌斯反演 说了这么多，终于到莫比乌斯反演了. 了解了狄利克雷卷积和狄利克雷逆，莫比乌斯反演就不在话下了. 我们定义单位函数 [公式] 的狄利克雷逆为 莫比乌斯函数 [公式] （或译作“默比乌斯函数”）： [公式] 上面这个式子就是莫比乌斯函数的狄利克雷逆定义式，如果用普通写法，莫比乌斯函数的普通定义式为： [公式] 其证明请参见 Mark Schachner 的 Paper 中的 Theorem 4.3. 互联网上不少介绍莫比乌斯反演的文章只给第二种定义，是因为莫比乌斯反演的讲解可以绕过狄利克雷卷积独立进行，但这样做会让一些读者不明白为什么这样定义，平添了许多麻烦. 我认为，在理解狄利克雷卷积的基础上谈论莫比乌斯反演是事半功倍的. 使用狄利克雷卷积来推导莫比乌斯反演公式就易如反掌了： [公式] 将其展开，也就是： [公式] 莫比乌斯反演公式的证明十分简单，在 [公式] 式的左式中同时卷积 [公式] 即可. 参考文献 芝加哥大学 Mark Schachner 的论文： Algebraic and Analytic Properties of Arithmetic Functions ; Wikipedia Dirichlet Convolution 条目 ; Pecco 知乎专栏《狄利克雷卷积》 ; Wikipedia Arithmetic Function 条目 . 感谢阅读，如果发现有误或不当的地方，我诚恳地希望您在下方评论区指出. 关于莫比乌斯反演公式的应用及延伸，我会在下一篇文章中提及，敬请期待.","link":"/note/misc/test/latex","is_index":false},{"title":"Markdown 测试","content":"普通文字 二级标题 三级标题 四级标题 五级标题 六级标题 选中 未选中 Sunt ullamco esse esse sit aliquip aliquip ea laboris ea nulla. Quis eiusmod enim aliqua consectetur sit ea. Commodo anim enim sit qui nisi culpa labore fugiat nisi est nulla ad. Dolore dolor magna Lorem sunt dolor commodo eu ad aliquip officia officia incididunt deserunt. Adipisicing veniam aliquip incididunt et amet velit nulla quis magna culpa aliqua nulla. Lorem proident Lorem nostrud elit quis quis id duis incididunt reprehenderit. Magna do ipsum incididunt nisi nisi do et consectetur excepteur amet. Irure qui aute incididunt velit consectetur nisi et sint elit dolor voluptate. Magna et non ullamco minim commodo amet culpa anim ea excepteur consequat pariatur laboris. Duis reprehenderit ipsum officia duis ut veniam. Ex deserunt labore velit minim laboris veniam magna velit exercitation ea minim. Velit amet veniam aute minim. Dolore occaecat officia minim dolor cupidatat ut sint. Tempor voluptate aliquip consectetur excepteur culpa. Et dolor in adipisicing commodo ex magna dolore ut aliquip. Nulla nisi nulla commodo id proident sit proident dolor dolore ipsum ullamco. Fugiat Lorem est sunt excepteur Lorem officia labore. Ut et tempor in exercitation nostrud amet eiusmod. Exercitation incididunt dolore cupidatat mollit veniam esse reprehenderit eiusmod cillum eu tempor dolor aliqua minim. Laboris voluptate consequat exercitation nisi ipsum. Cillum anim voluptate sunt est nostrud magna quis ad irure. 斜体 、 粗体 、 加粗斜体 、 删除线 在一个段落中的 文字链接 ，然后是后面的文字。 无序列表项 1 无序列表项 2 无序列表项 3 有序列表项 1 有序列表项 2 有序列表项 3 图片展示 这里是图片标题，支持 [公式] 和 加粗 文字 {\"cat /data/flag\"} 三级引用。Proident id dolore consectetur eu nulla anim sint magna veniam culpa mollit anim nostrud elit. Laboris ullamco nulla officia esse deserunt est aliqua. Ex deserunt mollit consectetur consequat duis deserunt et pariatur. Labore pariatur dolor ut excepteur amet ex fugiat amet tempor ullamco aute. Cupidatat non nulla ut laborum dolor nostrud quis quis. 二级引用。Exercitation aliquip commodo voluptate sit nulla. Voluptate laborum commodo esse elit culpa velit. Occaecat consequat pariatur deserunt nulla reprehenderit eiusmod. Consequat nostrud labore do laborum anim duis laborum proident laboris elit. Enim culpa aliqua voluptate aliqua dolor esse nisi culpa consectetur anim minim sint nulla incididunt. 一级引用。Et amet ea anim ut excepteur consequat amet dolore. Nulla incididunt do et minim do ea consequat aute dolore. Eiusmod exercitation proident aliqua et officia laborum occaecat reprehenderit exercitation ea ut fugiat pariatur. Anim do veniam ex pariatur proident quis id aute consequat incididunt excepteur quis tempor id. 多个引用 多个引用 多个引用 Cupidatat consequat incididunt nostrud laborum incididunt in sunt aute. Elit consectetur consectetur qui fugiat incididunt laborum amet officia quis cupidatat amet ut ullamco. Esse sunt aliqua commodo qui laboris sint enim. 行内代码块 {\"#include \"} 。Mollit dolore est in et aliquip adipisicing et nulla id nulla esse laborum minim nulla. In ad irure qui magna Lorem ad eiusmod do do {\"laborum ex duis\"} . Reprehenderit nulla nisi laborum incididunt voluptate sunt et cupidatat commodo consectetur deserunt. Non officia aliquip enim duis. Ea irure magna excepteur labore eiusmod officia sit id sint anim ipsum duis labore Lorem. Culpa cillum {\"voluptate duis exercitation cillum esse incididunt laborum magna\"} . Est ut commodo non magna nisi sit proident deserunt consectetur ut anim ullamco ut adipisicing. {\"scanf()\"} 用于输入数据，而 {\"printf()\"} 用于输出数据。 表格 Type Description {\"%\"} Prints {\"%\"} . {\"d\"} Decimal {\"signed int\"} . {\"u\"} Decimal {\"unsigned int\"} . {\"o\"} Octal {\"unsigned int\"} . {\"x\"} , {\"X\"} Hexadecimal {\"unsigned int\"} . {\"x\"} for lower-case and {\"X\"} for upper-case. {\"f\"} Float-point types in fixed-point notation. {\"e\"} , {\"E\"} Float-point types in exponential notation: {\"d.ddde±dd\"} . {\"e\"} for lower-case “e” and {\"E\"} for upper-case. {\"g\"} , {\"G\"} Float-point types in either fixed-point or exponential notation, whichever is more appropriate for its magnitude. {\"g\"} for lower-case and {\"G\"} for upper-case. {\"a\"} , {\"A\"} Float-point in hexadecimal notation, starting with {\"0x\"} or {\"0X\"} . {\"a\"} for lower-case and {\"A\"} for upper-case. {\"s\"} {\"null\"} -terminated string. {\"c\"} {\"char\"} . {\"p\"} {\"void*\"} in an implementation-defined format. {\"n\"} Print nothing, but writes the number of characters written so far into an integer pointer parameter. 代码块 # include <stdio.h> \\n\\n int main ( ) \\n { \\n printf ( \\\"Hello world\\\\n\\\" ) ; \\n printf ( \\\"Nulla culpa ut laborum sint esse elit minim sit. Eiusmod et exercitation et laboris voluptate aute et veniam excepteur. Anim dolore culpa commodo adipisicing et aute. In est aliquip duis tempor cillum ullamco qui. Et officia cillum ex et dolor esse magna veniam. Dolor sint velit dolor commodo in. Irure excepteur adipisicing dolore ipsum velit ipsum nisi Lorem pariatur dolor excepteur dolor dolor.\\\\n\\\" ) ; \\n return 0 ; \\n } \\n \"}> 这个代码块不带语言标识\\nlet a = 1;\\n \"}>","link":"/note/misc/test/markdown","is_index":false},{"title":"数理","content":"","link":"/note/sci","is_index":true},{"title":"线性代数","content":"","link":"/note/sci/la","is_index":true},{"title":"Prove That...","content":"C’mon, prove these linear algebra things! For the content below, I use [公式] to denote [公式] is a subspace of [公式], and [公式] to denote “there exists a unique”. Group, Ring & Field [公式] is a field. [公式] is the smallest number field (i.e. subfield of [公式]). Linear Space For [公式], [公式] is closed under addition and scalar multiplication. [公式]. If [公式] and [公式] are linearly independent, then [公式]. Functions [公式], [公式] and [公式] are linearly independent. ([公式], [公式] and [公式] are distinct) For [公式]: [公式] or [公式]. [公式]. [公式]. For [公式], the following propositions are equivalent: [公式]. [公式], [公式] and [公式] such that [公式]. If [公式], then [公式]. [公式]. Inner Product Space ( Cauchy–Schwarz inequality ) [公式]. ( Triangle inequality ) [公式]. ( Pythagorean theorem ) [公式]. ( Gram–Schmidt process ) Any Euclidean space has an orthonormal basis. (The method to construct it is called Gram–Schmidt process.) If [公式] is an orthonormal basis of [公式], then [公式], [公式]. Linear Transformation [公式] is injective [公式]. [公式] is surjective [公式]. If [公式] is a basis of [公式], then [公式], [公式] such that [公式]. For [公式], [公式]. For [公式], if [公式], the following propositions are equivalent: [公式] is injective. [公式] is surjective. [公式]. [公式]. Matrix [公式] and [公式] are one-to-one. Prove with matrix: if [公式], [公式], then [公式]. Prove with matrix: [公式].","link":"/note/sci/la/prove-that","is_index":false},{"title":"What is...","content":"Here are some easy-to-forget terms in linear algebra. Check whether you are familiar with them all. Set Power set , or [公式] and [公式] for a set [公式]. Group and Field Semigroup . Monoid . Group , or [公式]. Abelian group . Field , or [公式]. Vector Space Dimension , or [公式]. Rank , or [公式]. For [公式], what is [公式], [公式]. Inner product space . Euclidean space . Schmidt orthonormalization .","link":"/note/sci/la/what-is","is_index":false},{"title":"Cheatsheet","content":"Disclaimer : By saying “cheatsheet” I don’t mean something used for cheating, but rather a quick reference for the most important concepts and formulas. I don’t encourage cheating in any way. Equivalent Infinitesimals When [公式]: [公式] [公式] [公式] [公式] Derivatives [公式] [公式] [公式] [公式] Integrals [公式] [公式] [公式] [公式] [公式] [公式], [公式] [公式], [公式] [公式] [公式] [公式] [公式] [公式] Taylor Series With [公式] and [公式]: [公式] [公式] [公式] [公式] [公式] [公式] [公式] [公式] [公式] [公式]","link":"/note/sci/ma/cheatsheet","is_index":false},{"title":"Completeness of the Real Numbers","content":"Least upper bound property Every nonempty subset of [公式] having an upper bound has a least upper bound. Monotone convergence theorem If a sequence of [公式] is monotone and bounded, then it converges. Nested interval theorem For a sequence of closed intervals [公式], if [公式] for all [公式] and [公式], then exists exactly one [公式] so that [公式] for all [公式]. Bolzano-Weierstrass theorem Every bounded sequence of [公式] has a convergent subsequence. Cauchy criterion A sequence of [公式] is convergent if and only if it is a fundamental sequence. Fundamental sequence : A sequence [公式] is called a fundamental sequence if for all [公式], exists [公式] so that [公式] for all [公式] and [公式]. Fundamental sequence is also known as Cauchy sequence. Heine-Borel theorem If [公式] is an infinite open cover of closed interval [公式], then exists a finite subset [公式] so that [公式] is an open cover of [公式]. Or: If [公式] which satisfies [公式], then exists a finite subset [公式] so that [公式].","link":"/note/sci/ma/completeness-of-real-numbers","is_index":false},{"title":"数学分析","content":"","link":"/note/sci/ma","is_index":true},{"title":"Prove That...","content":"Here are theorems and proofs that are essential in mathematical analysis. It would be nice if you could prove them smoothly. Set ( De Morgan’s laws ) [公式] [公式] Any countable union of countable sets is a countable set. Limit of a sequence Prove with definition: [公式]. If [公式], then [公式]. For convergent sequences [公式] and [公式], if [公式], [公式], and [公式], then exists [公式] so that [公式] for all [公式]. If [公式], [公式], then [公式]. [公式] and [公式] converges to [公式]. [公式] converges to [公式]. [公式] converges to [公式]. [公式]. [公式] is convergent [公式] every non-trivial subsequence [公式] of [公式] converges. [公式] is divergent. Prove with Nested interval theorem : [公式] is uncountable. Refer to Completeness of the Real Numbers , and prove Least upper bound [公式] Monotone convergence . Monotone convergence [公式] Nested interval . Nested interval [公式] Bolzano-Weierstrass . Bolzano-Weierstrass [公式] Cauchy criterion . Cauchy criterion [公式] Least upper bound . Cauchy criterion [公式] Nested interval . Nested interval [公式] Least upper bound . Limit of a function If [公式], [公式] and [公式], then exists [公式] so that [公式] for all [公式]. If [公式], then exists [公式] so that [公式] is bounded in [公式]. Prove with definition: [公式]. ( Heine’s theorem ) The necessary and sufficient condition for [公式] is that for all sequences [公式] which converges to [公式] and [公式], [公式]. Prove with Heine’s theorem : [公式] has no limit as [公式]. ( Cauchy criterion ) Prove with Heine’s theorem : [公式] exists if and only if for all [公式], exists [公式] so that [公式] for all [公式]. Prove with definition: [公式]. Continuity Every irrational point of [公式] is continuous, every rational point of [公式] is removable discontinuous, where [公式] If [公式] is continuous at [公式], and [公式] is continuous at [公式], then [公式] is continuous at [公式]. If [公式] is continuous in closed interval [公式], then it is bounded in [公式]. then [公式] and [公式] exists in [公式]. and [公式], then exists [公式] so that [公式]. then it can reach all values between [公式] and [公式]. ( Cantor’s theorem ) then it is uniformly continuous in [公式]. The sufficient and necessary condition for [公式] to be uniformly continuous in [公式] is that for all sequences [公式] that satisfies [公式], [公式]. If [公式] is continuous in finite open interval [公式], then [公式] is uniformly continuous on [公式] if and only if [公式] and [公式] exist. Derivative ( Darboux’s theorem ) If [公式] is differentiable in [公式], then for every [公式] between [公式] and [公式], there exists [公式] so that [公式]. ( Rolle’s theorem ) If [公式] is continuous in [公式], differentiable in [公式], and [公式], then exists [公式] so that [公式]. If [公式] is twice differentiable in [公式], and [公式], then [公式], [公式], such that [公式]. If [公式] is bounded in [公式], then [公式] is uniformly continuous in [公式]. If [公式] is twice differentiable at [公式], [公式], and [公式], find [公式] and [公式]. (answer: [公式] and [公式]) point out two mistakes: [公式]. Prove using Taylor series with Lagrange remainder : [公式] is irrational.","link":"/note/sci/ma/prove-that","is_index":false},{"title":"Ch.27 Gauss' Law","content":"流量 Flux 流量 } expand>单位时间流过某表面的体积。 对于平面 [公式]： [公式] 一般式： [公式] 对于闭合曲面，若内部无源无汇，则 [公式]；若有源，则 [公式]，代表流出；若有汇，则 [公式]，代表流入。 Gauss’ Law 电通量 } expand>[公式] Gauss’ Law } expand type=\"success\">\n[公式] [公式]：闭合曲面内包围的电荷量。 [公式]：电荷体积密度。 [公式] 算符：[公式] 微分形式推导 首先由于数学上的 高斯公式 ，有 [公式] 而 [公式] 两式相等，故有 [公式] 证毕。 推 Coloumb’s Law 点电荷周围电场球形对称，取半径为 [公式] 的球面为高斯面，有 [公式] 故 [公式]，即 [公式] 即为 Coulomb’s Law。 应用 均匀带电球体 均匀带电球体 } expand>半径为 [公式] 的均匀带电球体，电荷密度为 [公式]，求球体内外的电场强度。 当 [公式] 时，取半径为 [公式] 的球面为高斯面，有 [公式] 故 [公式]（和点电荷的结果一致）。 当 [公式] 时，有 [公式] 其中 [公式] 故 [公式]（[公式]）。 电荷分布于导体表面 首先导体内电场一定为 [公式]，否则会有电荷在导体内部运动，违背静电平衡。 因此 [公式]，故 [公式]，即导体内部电荷量为 [公式]，说明导体所有电荷都分布于表面。 TBD","link":"/note/sci/phy/chapter-27","is_index":false},{"title":"物理学","content":"","link":"/note/sci/phy","is_index":true}];
const config: IFuseOptions<SearchTarget> = {"keys":["title","content"],"includeMatches":true,"ignoreLocation":true,"threshold":0.4};
const index: FuseIndex<SearchTarget> = Fuse.parseIndex<SearchTarget>(idx);
const fuse: Fuse<SearchTarget> = new Fuse(db, config, index);
const search: CachedSearchFn = (t: string) => (t ? fuse.search(t) : db);
export default search;
