import Fuse from "fuse.js";
const idx = {"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["content"],"id":"content","weight":1,"src":"content","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"摊还分析","n":1},"1":{"v":"设想一个栈的数据结构，在其上定义三种操作：[公式]、[公式]、[公式]。其中 [公式] 和 [公式] 顾名思义，[公式] 指连续地 [公式] 出栈中的 [公式] 个元素。 显然，[公式] 和 [公式] 都是 [公式] 的时间复杂度，[公式] 是 [公式] 的复杂度，其中 [公式] 为栈中元素的个数。 如果按照最坏情况来计算这个数据结构的复杂度，那么只要一次性 [公式] 出栈中所有 [公式] 个元素，就会消耗 [公式] 的时间，也就是说 最坏时间复杂度 （ Worst-case Time Complexity ）是 [公式]。但这能够代表实际使用中的表现吗？并不能，因为要想能 [公式] 出 [公式] 个元素，栈中必须至少有 [公式] 个元素，也就是说前面一定有不少于 [公式] 个复杂度为 [公式] 的 [公式] 操作。这样一均摊下来，每次操作的复杂度就是 [公式]。 像这样分析，我们得到整个数据结构的 平均时间复杂度 （ Average Time Complexity ）。但在实际研究中，要想达到真正的平均是很难的，因此我们引入 摊还时间复杂度 （ Amortized Time Complexity ）的概念， 它本质上是一个对平均时间复杂度的逼近 。 引入 在连续的 [公式] 次操作中，记 [公式] 为第 [公式] 次操作的开销（ Cost ），则 [公式] 我们希望构造出一组 摊还开销 （ Amortized Cost ） [公式]，使得 [公式] 能够反映 [公式] 的上界，即 [公式] 这样，如果我们能够想办法证明 [公式] 的，那么同时也就证明了 [公式] 也是 [公式] 的。因此，我们希望 [公式] 和 [公式] 之间的差距尽可能小，即 [公式] 在满足非负的同时尽可能小。 我们关注的重心即为如何构造这个 [公式]。 势能法 一种常用的分析方法是 势能法 （ Potential Method ）。它借用物理中势能的概念，给当前数据结构的状态 [公式] 赋予一个 势能 [公式]，并通过势能的变化来分析摊还开销。 取 [公式]，那么 [公式] 只要势函数 [公式] 选择得合适，保证 [公式] 始终非负，且初始情况的势能 [公式] 为 [公式]，那么就自然保证了 [公式] 的条件。这种需求显然更容易实现。 在上面的例子中，定义势函数 [公式] 为第 [公式] 次操作后 栈中的元素个数 ，则 [公式]。对于三种操作 [公式]：[公式]，摊还开销 [公式]。 [公式]：[公式]，摊还开销 [公式]。 [公式]：[公式]，摊还开销 [公式]。 因此 [公式] 所以 [公式]。这是比最坏时间复杂度更贴近于现实的复杂度。 Splay Tree 的摊还分析 在 Splay Tree 中，我们给每个节点定义一个 [公式]： [公式] 其中 [公式] 为节点 [公式] 包括自身的后代个数。 定义 [公式] 函数的目的是模拟树高。 在一个完全二叉树中，树高为 [公式] 的节点个数为 [公式]，此时 [公式] 就是树高 [公式]。虽然 Splay Tree 不一定是完全二叉树，但 [公式] 仍然可以作为树高的一个近似。后面我们会看到，相较于直接用树高分析，[公式] 的分析更为简单。 定义树 [公式] 的势函数 [公式] 显然，[公式] 恒非负，且空树的势能为 [公式]。 Splay Tree 的操作都由 Zig、Zag、Zig-Zag 三种子操作构成。我们对于每种子操作分别分析。 Zig 操作 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝑃 𝑋 𝑃 𝑅 𝑋 𝑅 𝑋 𝐿 \"} alt=\"初始情况：[公式]\">初始情况：[公式] .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝑃 𝑋 𝑋 𝑅 𝑃 𝑅 𝑋 𝐿 \"} alt=\"一次 Zig 操作后：[公式]\">一次 Zig 操作后：[公式] [公式] 由于变换后 [公式] 降低，所以 [公式]，因此 [公式] Zig-Zag 操作 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"初始情况：[公式]\">初始情况：[公式] .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"一次 Zig-Zag 操作后：[公式]\">一次 Zig-Zag 操作后：[公式] [公式] 这里 [公式] 是因为 Zig-Zag 操作需要两次旋转。 首先 [公式]，两者抵消。 同时我们注意到不等式 [公式]，左右同时取 [公式]（以 [公式] 为底），得到 [公式]。在其中令 [公式]，[公式]，则 [公式] 同时由于 [公式]，最终我们得到 [公式] Zig-Zig 操作 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"初始情况：[公式]\">初始情况：[公式] .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"一次 Zig-Zig 操作后：[公式]\">一次 Zig-Zig 操作后：[公式] [公式] 注意到 [公式]。剩下的证明与 Zig-Zag 类似，此处从略。最终我们得到 [公式] 摊还分析 根据上面的分析，我们得到 [公式] 这是一种非常优美的结构，因为对于一个完整的查询、插入、删除操作，它都是由一系列 Zig、Zig-Zag、Zig-Zig 子操作组成的，而这些子操作中的 [公式] 累加后 [公式] 相互抵消，只剩下初末状态的 [公式] 差值，同时我们知道末状态下 [公式] 就是根节点，也就是说 [公式] 为什么加的是常数 [公式] 呢？这是因为 Zig 永远只可能在最后一次子操作进行，最多只会执行一次。 据此，我们可以得到 Splay Tree 的摊还时间复杂度为 [公式]。 总结 上面的分析基于一个重要的假设：[公式]，但这一条件在有些情况下并不一定成立（例如 Splay Tree 初始非空）。实际上，如果这个假设不成立了，我们仍然能够得到一个较弱的结论：只要操作次数 [公式] 足够大，总体实际表现出来的复杂度仍然为 [公式]。 [公式] 只要初始状态给定，[公式] 实际上是一个常数。在这种情况下直接说 [公式] 也是合理的。如果想要更严谨一点，我们让 [公式]，这个时候常数也可以忽略不计了。","n":0.031}}},{"i":1,"$":{"0":{"v":"AVL Tree","n":0.707},"1":{"v":"AVL Tree 是在二叉搜索树的基础上实现的，对任何节点 [公式]，都有平衡因子 [公式]（其中空树高度定义为 [公式]），也即左右子树高度差不大于 [公式]。 这样得到的树虽然不一定是平衡二叉树，但能够保证高度是 [公式] 的，从而能够实现在 [公式] 的时间复杂度内完成插入、删除、查找的操作。 其中删除和查找和普通二叉搜索树并无二致，这里主要讨论插入操作。 维护 AVL Tree 平衡的方法是通过 旋转 操作，分为 LL-Rotation、LR-Rotation、RR-Rotation、RL-Rotation 这四种。 RR-Rotation 称在某个节点（不一定是根节点）的右节点（ R ight）的右子树（ R ight）上进行的 插入 操作为 RR 插入 。 如下左图，如果 [公式]、[公式] 节点的初始 [公式] 值分别为 [公式]、[公式]，在 [公式] 上进行一次 RR 插入后， 如果 [公式] 的右子树高度增加，那么 [公式]、[公式] 的 [公式] 值分别变为 [公式]、[公式]，此时 [公式] 节点不满足 AVL Tree 的条件，需要通过 RR-Rotation 操作来维护平衡（右图）。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 − 1 → − 2 𝐵 0 → − 1 𝐴 𝐿 𝐵 𝐿 𝐵 𝑅 \"} alt=\"RR-Rotation 操作前\">RR-Rotation 操作前 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐴 𝐿 𝐵 𝐿 𝐵 𝑅 \"} alt=\"RR-Rotation 操作后\">RR-Rotation 操作后 通过枚举容易证明，对于 RR 插入，只有这一种 [公式] 值需要旋转，其他 [公式] 情况要么不需要旋转，要么是在子树上进行旋转。对于后者，我们只需要保证 [公式] 是从新插入的节点往根节点回溯时遇到的第一个不平衡节点即可。 如果我们解决了 [公式] 的不平衡问题，由于 [公式] 这棵子树的高度并没有发生改变，我们已经可以断言整棵树已经平衡了（易证），在这种情况下已经没有必要继续向上回溯。 LL-Rotation LL-Rotation 与 RR-Rotation 类似，此处不再赘述。 点击展开示意图 } type=\"info\"> .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 1 → 2 𝐵 0 → 1 𝐴 𝑅 𝐵 𝑅 𝐵 𝐿 \"} alt=\"LL-Rotation 操作前\">LL-Rotation 操作前 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐵 𝑅 𝐴 𝑅 𝐵 𝐿 \"} alt=\"LL-Rotation 操作后\">LL-Rotation 操作后 LR-Rotation 顾名思义， LR-Rotation 发生在在左节点（ L eft）的右子树（ R ight）上进行插入时。 如下左图，若 [公式]、[公式]、[公式] 的初始 [公式] 值分别为 [公式]、[公式]、[公式]，在 [公式] 上进行一次 LR 插入，使得 [公式] 值分别变为 [公式]、[公式]、[公式]（[公式] 是因为我们既可能在 [公式] 的左子树上插入，也可能在右子树上插入）。这种情况下，我们需要进行 LR-Rotation 操作。 LR-Rotation 实际上是两步操作： 先在 [公式] 上进行一次 RR-Rotation； 再在 [公式] 上进行一次 LL-Rotation。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 1 → 2 𝐵 0 → 1 𝐶 0 → ± 1 𝐵 𝐿 𝐴 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 𝐵 𝐶 𝐵 𝐿 𝐴 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"在 [公式] 上进行 RR-Rotation\">在 [公式] 上进行 RR-Rotation .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐶 0 𝐵 𝐿 𝐴 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"在 [公式] 上进行 LL-Rotation\">在 [公式] 上进行 LL-Rotation 同样也可以证明，LR 插入只有这一种 [公式] 值需要旋转。并且旋转过后子树的高度没有改变，不需要继续向上回溯。 RL-Rotation 与 LR-Rotation 类似： 先在 [公式] 上进行一次 LL-Rotation； 再在 [公式] 上进行一次 RR-Rotation。 点击展开示意图 } type=\"info\"> .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 − 1 → − 2 𝐵 0 → − 1 𝐶 0 → ± 1 𝐵 𝑅 𝐴 𝐿 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 𝐵 𝐶 𝐵 𝑅 𝐴 𝐿 𝐶 𝑅 or 𝐶 𝐿 \"} alt=\"在 [公式] 上进行 LL-Rotation\">在 [公式] 上进行 LL-Rotation .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐶 0 𝐴 𝐿 𝐵 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"在 [公式] 上进行 RR-Rotation\">在 [公式] 上进行 RR-Rotation 复杂度证明 设 [公式] 为高度为 [公式] 的 AVL Tree 的 最小节点数 。为了在满足 AVL Tree 性质的前提下，使得节点数最小，任意节点 [公式] 的左右子树高度差（绝对值）一定为 [公式]。否则，如果高度相等，则一定可以再删除一个节点；如果高度差大于 [公式]，则不满足 AVL Tree 的性质。 也就是说任意高度为 [公式] 的节点一定是下图的两种情况之一： .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 ℎ ℎ − 1 ℎ − 2 \"} alt=\"空\"> .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 ℎ ℎ − 2 ℎ − 1 \"} alt=\"空\"> 从上面的分析我们得到如下等式： [公式] 等式左右同时 [公式]，得到 [公式]，说明数列 [公式] 是个类似 Fibonacci 数列的数列。 考虑边界条件，[公式]，[公式]，因此得到 [公式]。 我们知道 Fibonacci 数列的通项是 [公式] 其中 [公式] 表示离 [公式] 最近的整数。因此 [公式] 从而得到 [公式]，进而证明 AVL Tree 的插入、删除、查询操作的时间复杂度为 [公式]。 代码实现 为了计算 [公式] 值，我们需要在每个节点上维护其子树的高度信息，这是 AVL Tree 带来的额外开销。 插入函数 [公式] 的具体流程如下： 如果 [公式] 为空，返回一个新节点； 如果 [公式]，则递归插入到左子树，否则递归插入到右子树； 更新 [公式] 的高度信息； 计算 [公式] 的 [公式] 值，如果 [公式]（即不满足 AVL Tree），则根据对应的插入模式进行旋转，更新高度信息，返回新的根节点； 返回 [公式]。","n":0.024}}},{"i":2,"$":{"0":{"v":"B+ Tree","n":0.707},"1":{"v":"TBD","n":1}}},{"i":3,"$":{"0":{"v":"高级数据结构和算法分析","n":1},"1":{"v":"WIP","n":1}}},{"i":4,"$":{"0":{"v":"红黑树","n":1},"1":{"v":"根节点是黑色； 所有叶节点 NIL 是黑色； 红色节点的子节点一定是黑色； 从任意节点到其每个叶节点的路径上，黑色节点的数量（bh）相同。（一个很强的条件） Black-Height ：从某个节点到其每个叶节点的路径上的黑色节点数量。（不包括该节点） Lemma ：在一个有 [公式] 个内部节点的红黑树中，高度至多为 [公式]。 TBD","n":0.267}}},{"i":5,"$":{"0":{"v":"Splay Tree","n":0.707},"1":{"v":"在二叉搜索树的基础上，每次对节点的操作（查询、插入、删除）时，通过一些类似 AVL Tree 的旋转操作 将该节点移动到根节点 。 Splay Tree 的单次操作并不能达到 [公式] 的时间复杂度（在某些情况下甚至是 [公式] 的）。但可以证明，在任何连续的 [公式] 次操作后，能够保证 [公式] 的时间复杂度（即 摊还时间复杂度 ， Amortized Time Bound ）。 假如访问了节点 [公式]（在查询、插入后，删除前）： 如果 [公式] 是根节点，不进行任何操作； 如果 [公式] 的父节点是根节点，对 [公式] 进行一次 Single Rotation （即 AVL Tree 的 LL- 或 RR-Rotation，或称 Zig ），使得 [公式] 移动到根节点； 否则，记 [公式] 的父节点为 [公式]，祖父节点为 [公式]，分如下两种情况讨论。 Zig-Zag Zig-Zag 分为左右对称的两种情况，都是通过 Double Rotation （LR- 或 RL-Rotation）解决，下面以其中一种情况为例。 对于如下左图，通过在 [公式]、[公式]、[公式] 上进行 LR-Rotation 操作，从而把 [公式] 移动到根节点（如右图）。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"进行 Double Rotation 之后\">进行 Double Rotation 之后 Zig-Zig 这种情况是通过两次 Single Rotation 解决的，但是需要注意 旋转的顺序 ：从上往下先对 [公式] 进行一次旋转，再对 [公式] 旋转。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"进行两次 Single Rotation 之后\">进行两次 Single Rotation 之后 复杂度证明 见 摊还分析 。","n":0.041}}},{"i":6,"$":{"0":{"v":"C 语言","n":0.707}}},{"i":7,"$":{"0":{"v":"代码片段","n":1},"1":{"v":"夕事急像信行竹打尤生原 兔都身誰上；海就朱虎甲千。水畫花欠：首實幾朵種耳收園即歌消枝？爸但化冰點音拉外里，斗南外心怕黑見巾喜世力怕消進夕抄她。什麻連不跟友。步年他訴造荷四。 幼孝良把孝黃昔給姐間。就共陽。息雲扒：坡向跟神住；交直也哥幫實那得：苗蝶幸馬許行您弓她。六央路未久昌：壯幾姐交尺種有知後言後弟往開什筆往奶。首兆校您朵幼用具放詞犬彩民羽和冰、游綠言員休。 老婆國波；西功流聽、說王田是說戊色哥音每，帽動麻給說長起會陽旦青拉自木色正葉中點；什珠主兆記免鴨貫汁古畫朱且牠耍我，工想青字米寺早已足兌多請「學沒早虎」彩記心左現室，點百許了羽只。 祖詞三連從朱固巾向飛交黃比還兩牛夏停少歡。尺夕牙叫遠登京士音澡拍因止。干真朱兆世收雪吃食空屋吃！右尾九愛抱婆她以。 原雨夕空言車采這誰連信可雪，木刀原兔，良菜穴法法京斗示外九！的記息請力朋主跑棵平，喝您忍十得兒布頁春工竹？完母丟在念說追已良采風說信完風；聲父主。 杯世把那象他山丟象！木那把魚安戊拉村找每哪姐，苗麻還亮爪房美請身怕飽亮黃記這這毛，起麼早共三，飛尼哥用借女兔几。申司常昌兆洋聲您頁抱丟？音免荷松才開呢師後者怕前左占；食蝴辛心五，您勿爸說道花。 品息目丟同兒貫斗；不苗意過嗎朋後。 流訴蛋三自王戊就枝 光根百躲風書山青！占頭字打哭細母雪支尼，服點頭升音中們、房才兄教就人奶流光問直斥首月寸們戊，蝸斤刀千自胡耳羊游馬夕入活從虎跑月。問立來？荷沒兌禾同蝸。 現土耳遠上校條帶或田包起巴因有風，員行紅首別每天天向三念道更幸！麼爸欠前米給豆孝司弓！果功子士小昔乞去重五步開，送事福。 向經聲呀兆服兆光左那拉肖果新，兌婆石蝸瓜眼多「更果日服」吧連上文親後只左同回瓜看。住魚抱頭幾方意都夏司雞抱彩路口！南隻斗黑午屋送寺但食。那勿像左蛋而媽收工抱玉八免半荷中寫雞生。 在反出眼走各這弓奶西朋幫貓人字更他支，直流第，抄事再法跟封彩「嗎親外教回」回收室金土青好，孝由石！入小氣春。 停她里笑房或雞左同給浪口白躲哪走它嗎外黃有意。 今河姊訴遠棵師山經成和丁過心九 犬寫苗道蛋寺何子士，工明次，消由入？故面央肉從做冰戊刀王裏嗎要巾爬，畫結眼清抱朋八司給毛抄同兄時奶院因美泉字，來外月祖氣買綠黃家們沒母，寺合月甲連。 少心條麻過，下弓刀玩奶奶手造？事長即着也明胡條高雨法木未跳毛「道陽童多來在第午」皮內急青乍民奶右西半杯信丁辛布，喜出男爪很冒里菜爸哥造怪喝急波時彩水四，每瓜呢卜歡進。 孝瓜回經虎入走珠教、丟原可禾別從山隻。在勿犬「至候色寫因種七進丟朵」呀登香過是不飽奶。 飛但學直耳明根干做遠美 反很工苗巾司年法，頭師穿了固姊語節你三服雲安棵泉吃。嗎連寸穴兆行氣毛五美民怕去父足坐古色央植！河多媽流止，校掃生收蛋雲。 要服秋呀不眼「京娘老夏她來」言圓學乾穿貝久布布「喜圓乙造」躲安呀寺音功相久到世占害意員半：幼村福哪婆童弓第兒，爬帽言像借日千二紅嗎采司穿紅蝴天豆前、裏還共物。抄停假七？具着牙寸合弓吃親；遠父右。 又穿早掃紅面課把家貓不根着旦條何但，貝多貫斤斗都男面夏你生東王！頁背昔尾秋王麼笑路棵道面，春我金神雨或天吉她，包工冰泉百「空寫貝眼」發巴。 造從真夏着共孝穴毛定姊得方別男、他封言朵，且連再幾眼百、至月重坐候發幸入布士子力支吉衣門占布明，常乍她者放玩裏實師民，您爬綠家弓服干問看兌我。 飯兌找公到點。杯身紅間各喝月室奶拉家，植羊春家大亭助歡明黑加，已良呢找？昌雨室書院我就；走申洋羊回快王意拉八哪員發彩子刀兩住拍；現給南氣登巾。林方不。貝細午。 弓由消方老犬次美，瓜土信晚姐早結言卜直力，工干節什故。圓丟斗天干吃松頭平久服園。好背心直什忍爸做丟寫抓工。比斗羽白怪：科連止行波石呢，請坡視喜彩乍。 欠戊北知友牛冬蝴定以丟過良祖行祖耳「九寫月住」信安兒父她帶布媽師食王間把帶物躲怪朋！只筆固且而它比。 未就收苗貓呢晚小種辛風亮跳口經 躲犬蛋肉里你反立首火，院急跟重毛音戊眼他聽黃文卜海幸筆彩色急六，急買犬抱？怕助方自學飯信尼巴汗。嗎免細前間飯雪七燈陽青：苦黑品小泉假乾躲。 麼空步朋科午海很苦牠且丁火口帽苗寫每。力車每，想好消外室百馬弟動夏北邊習口空課寺。或早笑國世植雲入候視紅再位娘怪占紅了去。 記巾爬由汁兔歡坡！夏門衣人今。進下中固？跑第白是白魚吹手筆七相弓手象現拉重。升歡清兌拉記個圓位采重泉飛尺道。兩發重水乾安至十斗老朵有。 出做意嗎鳥固吧那玉苗條飽空游首止女虎荷杯，月屋念帶右心得能她葉次位合魚園昌澡壯示喜，園交玉有起聽；入別了給。 已聲停青教手京送第知巾，共視隻河連樹光土愛九吹去戶安坡；多玉菜丁根彩生背，對我夕游斗生，像山陽男虎年空信快間。波園明升沒它日位許化對石歡請小、姊扒甲升。 很她雞公做牠笑毛西哭乞後幼童喝雄姐！親帽娘夕隻合二了誰還會去每；彩動澡海打貝士面背住錯。書坐前房科丟聽時杯天刃吧身視首再、己看綠以爬放原飽哥良喜能。 壯沒立兩下、風還牠比新四。七訴像，太化夏頭到河從申。朋息問訴好奶歡二中院院即意主什燈，裝送氣停怪亮洋心跳好天刃孝地公久再聲雄；問虎爪停星飯肉斤玉隻第。 消支嗎也對走片像間穿戊枝停游占根外刀：兒後要清，尤清馬蝸三要寸像，澡雲內羽視能第主他同習尾玩拍三旦您背今。孝丁米乞星耍哭。 生巾次而英具停筆好貝乞麼拍真它欠久「出固飽經國才科日」每吃九法出冰功父哪語得聲未朋枝雪方笑友光。牛哭又雲首每飛友，掃兄目行。 就九斗央哭是刀牙竹青八冬枝，假意又戶斥細文抄甲巾語活戶「夕勿什平日」做過課常一巴現亭課耳邊話意比送，十貓兌何亭肖也波羽兩己叫汗白流畫，巾安胡意北心常何直走辛見吧京者行王刀喝各請青外。 汁請個實進以聽喝、但植兔反很沒爬嗎去忍且聲民「波燈」外植隻十南從們常友力壯唱以棵陽唱朱尼！神身來相童位？往連世花叫珠打休活，急蝸雨跑室聽果嗎辛很進巾奶立身人文。 相種古亮雲向下新聲尾得媽根辛用他，平哪哭化六們花。吹音免友中停現六耍朋由起進！我衣杯詞蝶河植蝸牛坐前。子邊七習秋頁陽重親相小呀手做占胡止；面人免辛兩跟右躲借泉。 央教昌過走旁；功青二菜石果亭元？從童貓跳那買院怪占幫司叫半花跑、把寺太右「的彩呢免朵」請心可言大女實未面；看屋弟尾吉國飽次金音汁。媽日幾七戶玉讀今停進者外行就！犬多見欠？植娘帶加節四。 過很幼菜；刃但喝寸喝四追由幾力跟刃。弟牙海山休喜肉怪升故哪蝸假旁身金尺，子寺山斗坡點位，各成壯。松澡怎。占河花朋得。","n":0.156}}},{"i":8,"$":{"0":{"v":"计算机科学","n":1}}},{"i":9,"$":{"0":{"v":"自定义语法","n":1},"1":{"v":"数学公式 利用 KaTeX 渲染数学公式。 行内公式 ... $ < 公式内容 > $ ...\\n \"}> 效果 可以不难推得 [公式]。 [公式] 这个名字来源于单词 Decade：[公式]。 源码 可以不难推得 $\\\\varphi(n):=n\\\\prod_{p\\\\mid n}(1-\\\\frac{1}{p})$。\\n\\n$\\\\mathfrak{Xecades}$ 这个名字来源于单词 Decade：$\\\\text{10 Decades}\\\\rightarrow \\\\text{X Decades}\\\\rightarrow \\\\text{Xecades}$。\\n \"}> 行间公式 $$\\n < 公式内容 > \\n$$\\n \"}> 效果 [公式] 源码 $$\\n\\\\begin{aligned}\\n&\\\\Bigl(f*g\\\\Bigr)(6) \\\\\\\\\\n=&\\\\sum_{d\\\\mid 6}f(d)g\\\\biggl(\\\\dfrac{6}{d}\\\\biggr) \\\\\\\\\\n=&f(1)g(6)+f(2)g(3)+f(3)g(2)+f(6)g(1)\\n\\\\end{aligned}\\n$$\\n \"}> Icon 使用 FontAwesome 加载 SVG 图标。 ... : < icon > : ...\\n \"}> 效果 The magic spell will lead you to the treasure . 源码 The * magic spell * :arrow-up: :arrow-up: :arrow-down: :arrow-down: :arrow-left: :arrow-right: :arrow-left: :arrow-right: :a: :b: :a: :b: will lead you to the treasure :sack-dollar:.\\n \"}> 引言 适合用于展示名言、引用等。 ::quote\\n < 引言内容 > \\n::\\n \"}> 效果 Two roads diverged in a wood, and I— I took the one less traveled by , And that has made all the difference. —Robert Frost 源码 :::quote\\nTwo roads diverged in a wood, and I—\\\\\\nI took * the one less traveled by * ,\\\\\\nAnd that has made all the difference.\\\\\\n < right > —Robert Frost </ right > \\n:::\\n \"}> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. [公式] Note 功能上类似于 MkDocs Material 的 Admonitions ，用于提供额外信息。 ::note{[default] | primary | success | info | warning | danger}\\n < Note 内容 > \\n::\\n \"}> 效果 这里是 note.default 的内容 源码 :::note\\n这里是 `note.default` 的内容\\n:::\\n \"}> 效果 [公式] 源码 :::note{danger}\\n$\\\\text{P} \\\\neq \\\\text{NP}$\\n:::\\n \"}> 这里是 note.primary 的内容 这里是 note.success 的内容 这里是 note.info 的内容 这里是 note.warning 的内容 这里是 note.danger 的内容 Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 折叠面板 ::fold{title=\\\"[标题]\\\" [ expand ] [ default ] | primary | success | info | warning | danger}\\n < 折叠内容 > \\n::\\n \"}> 效果 默认展开的 default 折叠面板 } expand>这里是 fold.default 的内容 源码 :::fold{title=\\\"默认展开的 `default` 折叠面板\\\" expand}\\n这里是 `fold.default` 的内容\\n:::\\n \"}> primary 折叠面板 } type=\"primary\">这里是 fold.primary 的内容 success 折叠面板 } type=\"success\">这里是 fold.success 的内容 info 折叠面板 } type=\"info\">这里是 fold.info 的内容 warning 折叠面板 } type=\"warning\">这里是 fold.warning 的内容 danger 折叠面板 } type=\"danger\">这里是 fold.danger 的内容 标题是支持 [公式] 的 } expand type=\"success\"> 折叠面板也支持 [公式]！ [公式] Lorem } type=\"danger\"> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Veniam irure ipsum dolore dolore Lorem voluptate adipisicing eiusmod minim. Eu incididunt enim irure nisi. Amet eu nostrud irure Lorem mollit eu ipsum excepteur cillum irure in sint reprehenderit deserunt. Occaecat adipisicing culpa excepteur magna id dolor exercitation ut ea dolor ut veniam est eiusmod. Consequat qui ut labore dolor ut. Ipsum ullamco commodo veniam occaecat fugiat sint consectetur nisi deserunt sunt ullamco et veniam. Do commodo mollit voluptate veniam ipsum irure dolore nisi. 这个折叠面板没有标题 这个折叠面板的标题真的真的真的真的真的真的真的真的真的真的真的真的非常的长，而且里面还有 code 块 }> print ( \\\"Hello World\\\" ) \\n \"}> 链接卡片 ::linkcard{href=\\\" < 链接地址 > \\\"}\\n < 链接名称 > \\n::\\n \"}> 效果 Xecades 的博客 源码 :::linkcard{href=\\\"https://blog.xecades.xyz/\\\"}\\nXecades 的博客\\n:::\\n \"}> [公式] 的 GitHub 仓库 Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Typst 渲染 基于 Typst.ts 实现 Typst 的渲染。 ```typst [标题]\\n<Typst 代码>\\n```\\n \"}> 效果 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 15 13 12 14 17 16 18 18 \"} alt=\"一棵来自 Typst 的树\">一棵来自 Typst 的树 源码 ``` typst 一棵来自 ***Typst*** 的树 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([15], ([13], [12], [14]), ([17], [16], ([18], [], [18])))\\n    )\\n}) \\n ``` \\n \"}> 选项卡 ::tab\\n # <选项卡 1> \\n\\n < 选项卡 1 内容 > \\n\\n # <选项卡 2> \\n\\n < 选项卡 2 内容 > \\n\\n[...]\\n::\\n \"}> 选项卡 1 这里是「 选项卡 1 」 的内容 选项卡 2 这里是「 选项卡 2 」 的内容 [公式] 公式 选项卡也是支持 [公式] 的！ [公式] Lorem Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 一个名字很长很长很长很长很长很长的选项卡（而且名字里面还有 code ） print ( \\\"Hello World\\\" ) \\n \"}> 源码 :::tab\\n # 选项卡 1 \\n\\n这里是「 ** 选项卡 1 ** 」 的内容\\n\\n # 选项卡 2 \\n\\n这里是「 ** 选项卡 2 ** 」 的内容\\n\\n # $\\\\LaTeX$ 公式 \\n\\n选项卡也是支持 $\\\\LaTeX$ 的！\\n\\n$$\\n\\\\begin{aligned}\\n&\\\\Bigl(f*g\\\\Bigr)(6) \\\\\\\\\\n=&\\\\sum_{d\\\\mid 6}f(d)g\\\\biggl(\\\\dfrac{6}{d}\\\\biggr) \\\\\\\\\\n=&f(1)g(6)+f(2)g(3)+f(3)g(2)+f(6)g(1)\\n\\\\end{aligned}\\n$$\\n\\n # Lorem \\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\n\\n # 一个名字很长很长很长很长很长很长的选项卡（而且名字里面还有 `code`） \\n\\n ``` python \\n print ( \\\"Hello World\\\" ) \\n ``` \\n:::\\n \"}> 唯一一个 Tab！ 这个选项卡只有这一个 Tab Grid ::grid\\n:sep{width=\\\" < 宽度 > \\\"}\\n\\n < 内容 1 > \\n\\n:sep{width=\\\" < 宽度 > \\\"}\\n\\n < 内容 2 > \\n\\n[...]\\n::\\n \"}> 效果 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 20 16 13 18 25 21 28 \"} alt=\"二叉搜索树 例 1\"> 二叉搜索树 例 1 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 10 5 2 7 15 \"} alt=\"二叉搜索树 例 2\"> 二叉搜索树 例 2 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 15 13 12 14 17 16 18 18 \"} alt=\"二叉搜索树 例 3\"> 二叉搜索树 例 3 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 16 10 7 1 15 19 17 18 20 \"} alt=\"二叉搜索树 例 4\"> 二叉搜索树 例 4 源码 :::grid\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 1 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([20], ([16], [13], [18]), ([25], [21], [28]))\\n    )\\n}) \\n ``` \\n\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 2 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([10], ([5], [2], [7]), [15])\\n    )\\n}) \\n ``` \\n\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 3 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([15], ([13], [12], [14]), ([17], [16], ([18], [], [18])))\\n    )\\n}) \\n ``` \\n\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 4 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([16], ([10], ([7], [1], []), [15]), ([19], ([17], [], [18]), [20]))\\n    )\\n}) \\n ``` \\n\\n:::\\n \"}>","n":0.023}}},{"i":10,"$":{"0":{"v":"测试","n":1},"1":{"v":"标点挤压测试（（文字）），（文）「字」。 [公式][公式]","n":0.707}}},{"i":11,"$":{"0":{"v":"LaTeX 测试","n":0.707},"1":{"v":"狄利克雷卷积 （Dirichlet Convolution）在解析数论中是一个非常重要的工具. 使用狄利克雷卷积可以很方便地推出 莫比乌斯反演 （Möbius Inversion）相关重要函数和公式，它在信息学竞赛和解析数论中至关重要. 很多初学者不能真正地理解莫比乌斯反演，或者说即使能使用最终的公式，也难以理清楚它是怎么推导的. 本文中，我将尝试使用一种新的方式讲解狄利克雷卷积和莫比乌斯反演，希望能对大家有所帮助. 文中的引语（浅色文字）是可选内容，为正文的补充或提示. 阅读时，你可以选择跳过这部分文字，而不会影响内容连贯性. 什么是狄利克雷卷积 狄利克雷卷积是定义在 数论函数 间的二元运算. 所谓 数论函数 ，是指定义域为 [公式]（ 自然数 ），值域为 [公式]（ 复数 ） 的一类函数，每个数论函数可以视为复数的序列. 它最常见的定义式为： [公式] 这里提醒一个很明显的事实：在这个定义式中，右式的函数 [公式] 和 [公式] 括号中的参数是可以调换的，即： [公式] 如果我们比较关注式子的对称性，下面有狄利克雷卷积的另一个定义式： [公式] 下面举一个例子，以方便理解： [公式] 在后面的文章中我们会反复应用这两个定义式. 为什么叫“狄利克雷卷积”呢？ 首先， 狄利克雷 （Gustav Lejeune Dirichlet）是 19 世纪德国的数学家，他是解析数论的创立者，是解析数论很多重要理论的提出者. 至于“卷”，可以理解为在二维平面上延伸的两个数论函数（一个沿 x 轴，一个沿 y 轴）像卷毛巾一样交叉结合起来. “积”这个字在定义式中的星号 [公式] 体现出来了，如果定义普通函数加法为数论函数间的“加”运算，那么这里的狄利克雷卷积就是数论函数的“乘”运算，这一点我会在后文再次提到. 本文要用到的数论函数 还记得到吗？数论函数都是 [公式] 类型的. 下面我来列举一些常用的数论函数. 初看时你可能会觉得这些定义没有什么用，但它们在狄利克雷卷积中大多是作为记号存在的. 单位函数 [公式] [公式] 幂函数 [公式] [公式] 特别地，有： 当 [公式] 时，为 恒等函数 [公式]，即 [公式]. 当 [公式] 时，为 常数函数 [公式]，即 [公式]. 这里的常数函数 [公式] 的函数名是 加粗了 的数字 [公式]，不要和 [公式] 弄混了.\n在某些场合，有人会用大写字母 [公式] 来代替 [公式]，以防混淆，这里还是使用 [公式]. 除数函数 [公式] 直观上理解，除数函数就是其所有因数的 [公式] 次方之和. [公式] 特别地，有： 当 [公式] 时，为 因数函数 [公式]，即 [公式]. 当 [公式] 时，为 个数函数 [公式]，即 [公式]. 从“因数函数”和“个数函数”这两个名字就可以看出来，[公式] 表示 [公式] 的因数之和，[公式] 表示 [公式] 的因数个数. 例如，[公式]，[公式]. 对于因数函数和个数函数，设 [公式]，其中 [公式]，可以得到这两个计算式（不是重点，证明从略）： [公式] 欧拉函数 [公式] 欧拉函数博大精深，这里只介绍一些内容. [公式] 表示小于 [公式] 的正整数中与 [公式] 互质的数的个数. 可以不难推知（证明从略）： [公式] 总共（提及的）有： 单位函数 [公式]、 幂函数 [公式]（含 恒等函数 [公式] 和 常数函数 [公式]）、 除数函数 [公式]（含 因数函数 [公式] 和 个数函数 [公式]）、 欧拉函数 [公式]. 上面提到的 所有 函数都是 积性函数 ，其中 单位函数 和 幂函数 是 完全积性函数 （证明从略）. 积性函数 是指对 所有互质的整数 [公式] 和 [公式] 都有 [公式] 的数论函数. 完全积性函数 是指对 所有整数 [公式] 和 [公式] 都有 [公式] 的数论函数. 在 [公式] 式中令 [公式]，得到 [公式]，这也是积性函数一重要特点. 狄利克雷卷积相关定理 读者不妨先不看证明，自己试着证一下. [1] 若 [公式]，[公式] 为积性函数，则 [公式] 也是积性函数. 设 [公式]（即 [公式] 和 [公式] 互质）则： [公式] 在将 [公式] 合并成 [公式] 的操作中，用到了由 [公式]、[公式] 互质推导出来的结论：[公式] 的因数唯一表示为 [公式] 的因数与 [公式] 的因数的乘积，因此 [公式] 和 [公式] 是完全等价的. [2] 狄利克雷卷积满足交换律，即 [公式]. [公式] 在 [公式] 中，我将 [公式] 和 [公式] 换了个位置（也就是 [公式] 写成 [公式]，[公式] 写成 [公式]. 实际上这不是必须的），然后把 [公式] 挪到了 [公式] 的前面. 这里我用的是第二个定义式，它的优点是对称性好，用来证明交换律很直观. [3] 狄利克雷卷积满足结合律，即 [公式]. [公式] 从 [公式] 开始，类似地也可以得到 [公式]，因此它们相等，结合律成立. [4] 狄利克雷卷积满足分配律，即 [公式]. [公式] 这里总结一下我们证了的式子： 若 [公式]，[公式] 为积性函数，则 [公式] 也是积性函数. 狄利克雷卷积满足 交换律 ，即 [公式]. 狄利克雷卷积满足 结合律 ，即 [公式]. 狄利克雷卷积满足 分配律 ，即 [公式]. 这些结论十分重要，后文中我可能会在不说明的情况下直接使用这些结论. 为什么是“积”？ 现在我们可以得出原因了，狄利克雷卷积满足 交换律 、 结合律 和 分配律 ，其运算法则和普通算数乘法完全类似（在小学的时候我们就已经学过乘法的三定律了）. 实际上，狄利克雷卷积和普通函数加法可以构成一个 阿贝尔环 ，你甚至可以在它的基础上构建以函数为自变量的多项式，并解它的根. 一些特殊的卷积 看到这里，前文提到的数论函数才能真正地起作用. [1] [公式] [公式] 在证明的过程中，我们发现：如果一个函数和 [公式] 作狄利克雷卷积，就相当于把其参数的所有因子枚举出来并代入原函数，然后求和. 也就是说： [公式] 无论是正向操作还是反向操作，这个式子都很重要. [2] [公式] 再提醒一下，[公式] 的定义是这样的： [公式] 首先有： [公式] 尝试对 [公式] 进行拆分，当 [公式] 时，有： [公式] 考虑更普遍的情况，当 [公式] 为任意正整数，分解 [公式]，因为 [公式] 是积性函数，所以： [公式] 综上，[公式]. [3] [公式] 这个证明相对更简单. [公式] 上面我们只列举出了三个常用的狄利克雷卷积结果，分别是： [公式]; [公式]; [公式]. 实际上，通过这几个运算我们可以得到更多的运算，例如： [公式] 单位元 乘法的 单位元 是指乘上它后值不改变的数（对狄利克雷卷积来说，是“函数”）. 例如，普通乘法的单位元是数字 [公式]，因为 [公式]. 因此，在狄利克雷卷积中，它的单位元 [公式] 就应该满足 [公式]. 我们注意到这样一个事实： [公式] 因此，狄利克雷卷积的单位元就是 单位函数 [公式]，它在狄利克雷卷积中的作用和 1 在普通乘法中的作用是类似的. 任何函数（ 包括 [公式] ）和 [公式] 进行狄利克雷卷积，都得到该函数本身. 还记得到吗？[公式] 的定义是这样的： [公式] 狄利克雷逆（Dirichlet Inverse） 我们可以把这里的“ 逆 ”和“ 逆元 ”作类比. 例如，在普通运算中，一个数的“逆元”就是这个数的倒数；在同余运算中，一个数的“逆元”在同个模的意义下，能使得它与这个数相乘的结果与 [公式] 同余. 分别而言，如果我们规定 [公式] 的逆元是 [公式]（这个符号是作为整体引入的， 大多数情况下不能简单地理解为 [公式] ），那么就有这样两个式子： [公式] 数字 [公式] 是两种运算中的单位元，所以说，逆元在类似乘法的运算中起着“倒数”的地位. 在狄利克雷卷积中，单位元是 [公式]，我们定义狄利克雷逆如下： [公式] 函数 [公式] 就被称为 [公式] 的 狄利克雷逆 . 对于狄利克雷逆公式的推导，可以使用 合情推理 的方法（列出 [公式]，然后找规律），得到狄利克雷逆的计算式： [公式] 这个式子我们不推导，仅证明它是成立的: 当 [公式] 时，[公式]. 当 [公式] 时， [公式] 也就是说，[公式]. 因此这个计算式是成立的. 值得注意的是，狄利克雷逆的计算式中包含了自身，也就是说它是个 递归形式的定义 . 若将其展开，则过于复杂，（一般）没有实际意义. 一个数论函数 [公式] 存在狄利克雷逆的 充要条件 是 [公式]，在狄利克雷逆的推导过程中，我们知道 [公式] 的逆是唯一的 . 需要指出， 积性函数一定有狄利克雷逆，且它也是积性函数 ，该证明从略（请参见芝加哥大学 Mark Schachner 的 Paper ）. 当 [公式] 且 [公式] 时，有 [公式]，证明如下： [公式] 由狄利克雷逆的唯一性，[公式] 的狄利克雷逆是唯一的，所以 [公式]. 莫比乌斯反演 说了这么多，终于到莫比乌斯反演了. 了解了狄利克雷卷积和狄利克雷逆，莫比乌斯反演就不在话下了. 我们定义单位函数 [公式] 的狄利克雷逆为 莫比乌斯函数 [公式] （或译作“默比乌斯函数”）： [公式] 上面这个式子就是莫比乌斯函数的狄利克雷逆定义式，如果用普通写法，莫比乌斯函数的普通定义式为： [公式] 其证明请参见 Mark Schachner 的 Paper 中的 Theorem 4.3. 互联网上不少介绍莫比乌斯反演的文章只给第二种定义，是因为莫比乌斯反演的讲解可以绕过狄利克雷卷积独立进行，但这样做会让一些读者不明白为什么这样定义，平添了许多麻烦. 我认为，在理解狄利克雷卷积的基础上谈论莫比乌斯反演是事半功倍的. 使用狄利克雷卷积来推导莫比乌斯反演公式就易如反掌了： [公式] 将其展开，也就是： [公式] 莫比乌斯反演公式的证明十分简单，在 [公式] 式的左式中同时卷积 [公式] 即可. 参考文献 芝加哥大学 Mark Schachner 的论文： Algebraic and Analytic Properties of Arithmetic Functions ; Wikipedia Dirichlet Convolution 条目 ; Pecco 知乎专栏《狄利克雷卷积》 ; Wikipedia Arithmetic Function 条目 . 感谢阅读，如果发现有误或不当的地方，我诚恳地希望您在下方评论区指出. 关于莫比乌斯反演公式的应用及延伸，我会在下一篇文章中提及，敬请期待.","n":0.045}}},{"i":12,"$":{"0":{"v":"Markdown 测试","n":0.707},"1":{"v":"普通文字 二级标题 三级标题 四级标题 五级标题 六级标题 选中 未选中 Sunt ullamco esse esse sit aliquip aliquip ea laboris ea nulla. Quis eiusmod enim aliqua consectetur sit ea. Commodo anim enim sit qui nisi culpa labore fugiat nisi est nulla ad. Dolore dolor magna Lorem sunt dolor commodo eu ad aliquip officia officia incididunt deserunt. Adipisicing veniam aliquip incididunt et amet velit nulla quis magna culpa aliqua nulla. Lorem proident Lorem nostrud elit quis quis id duis incididunt reprehenderit. Magna do ipsum incididunt nisi nisi do et consectetur excepteur amet. Irure qui aute incididunt velit consectetur nisi et sint elit dolor voluptate. Magna et non ullamco minim commodo amet culpa anim ea excepteur consequat pariatur laboris. Duis reprehenderit ipsum officia duis ut veniam. Ex deserunt labore velit minim laboris veniam magna velit exercitation ea minim. Velit amet veniam aute minim. Dolore occaecat officia minim dolor cupidatat ut sint. Tempor voluptate aliquip consectetur excepteur culpa. Et dolor in adipisicing commodo ex magna dolore ut aliquip. Nulla nisi nulla commodo id proident sit proident dolor dolore ipsum ullamco. Fugiat Lorem est sunt excepteur Lorem officia labore. Ut et tempor in exercitation nostrud amet eiusmod. Exercitation incididunt dolore cupidatat mollit veniam esse reprehenderit eiusmod cillum eu tempor dolor aliqua minim. Laboris voluptate consequat exercitation nisi ipsum. Cillum anim voluptate sunt est nostrud magna quis ad irure. 斜体 、 粗体 、 加粗斜体 、 删除线 在一个段落中的 文字链接 ，然后是后面的文字。 无序列表项 1 无序列表项 2 无序列表项 3 有序列表项 1 有序列表项 2 有序列表项 3 图片展示 这里是图片标题，支持 [公式] 和 加粗 文字 cat /data/flag 三级引用。Proident id dolore consectetur eu nulla anim sint magna veniam culpa mollit anim nostrud elit. Laboris ullamco nulla officia esse deserunt est aliqua. Ex deserunt mollit consectetur consequat duis deserunt et pariatur. Labore pariatur dolor ut excepteur amet ex fugiat amet tempor ullamco aute. Cupidatat non nulla ut laborum dolor nostrud quis quis. 二级引用。Exercitation aliquip commodo voluptate sit nulla. Voluptate laborum commodo esse elit culpa velit. Occaecat consequat pariatur deserunt nulla reprehenderit eiusmod. Consequat nostrud labore do laborum anim duis laborum proident laboris elit. Enim culpa aliqua voluptate aliqua dolor esse nisi culpa consectetur anim minim sint nulla incididunt. 一级引用。Et amet ea anim ut excepteur consequat amet dolore. Nulla incididunt do et minim do ea consequat aute dolore. Eiusmod exercitation proident aliqua et officia laborum occaecat reprehenderit exercitation ea ut fugiat pariatur. Anim do veniam ex pariatur proident quis id aute consequat incididunt excepteur quis tempor id. 多个引用 多个引用 多个引用 Cupidatat consequat incididunt nostrud laborum incididunt in sunt aute. Elit consectetur consectetur qui fugiat incididunt laborum amet officia quis cupidatat amet ut ullamco. Esse sunt aliqua commodo qui laboris sint enim. 行内代码块 #include<iostream> 。Mollit dolore est in et aliquip adipisicing et nulla id nulla esse laborum minim nulla. In ad irure qui magna Lorem ad eiusmod do do laborum ex duis . Reprehenderit nulla nisi laborum incididunt voluptate sunt et cupidatat commodo consectetur deserunt. Non officia aliquip enim duis. Ea irure magna excepteur labore eiusmod officia sit id sint anim ipsum duis labore Lorem. Culpa cillum voluptate duis exercitation cillum esse incididunt laborum magna . Est ut commodo non magna nisi sit proident deserunt consectetur ut anim ullamco ut adipisicing. scanf() 用于输入数据，而 printf() 用于输出数据。 表格 Type Description % Prints % . d Decimal signed int . u Decimal unsigned int . o Octal unsigned int . x , X Hexadecimal unsigned int . x for lower-case and X for upper-case. f Float-point types in fixed-point notation. e , E Float-point types in exponential notation: d.ddde±dd . e for lower-case “e” and E for upper-case. g , G Float-point types in either fixed-point or exponential notation, whichever is more appropriate for its magnitude. g for lower-case and G for upper-case. a , A Float-point in hexadecimal notation, starting with 0x or 0X . a for lower-case and A for upper-case. s null -terminated string. c char . p void* in an implementation-defined format. n Print nothing, but writes the number of characters written so far into an integer pointer parameter. 代码块 # include <stdio.h> \\n\\n int main ( ) \\n { \\n printf ( \\\"Hello world\\\\n\\\" ) ; \\n printf ( \\\"Nulla culpa ut laborum sint esse elit minim sit. Eiusmod et exercitation et laboris voluptate aute et veniam excepteur. Anim dolore culpa commodo adipisicing et aute. In est aliquip duis tempor cillum ullamco qui. Et officia cillum ex et dolor esse magna veniam. Dolor sint velit dolor commodo in. Irure excepteur adipisicing dolore ipsum velit ipsum nisi Lorem pariatur dolor excepteur dolor dolor.\\\\n\\\" ) ; \\n return 0 ; \\n } \\n \"}> 这个代码块不带语言标识\\nlet a = 1;\\n \"}>","n":0.036}}},{"i":13,"$":{"0":{"v":"ToC 测试","n":0.707},"1":{"v":"普通标题 1-1 一些内容 另一个标题 # 这里不应该被识别为标题\\n## 这里也是\\n###and this\\n \"}> 但是这里应该被判定为标题 # 这里不应该被识别为标题\\n \"}> 这里也是 这个标题内还有 [公式] 数学公式 这个标题里面有 code 块 这个 意大利的 标题非常 强壮","n":0.204}}},{"i":14,"$":{"0":{"v":"笔记","n":1}}},{"i":15,"$":{"0":{"v":"离散数学","n":1}}},{"i":16,"$":{"0":{"v":"离散傅里叶变换和离散傅里叶反变换文字文字文字文字文字文字文字文字文字文字","n":1},"1":{"v":"离散傅里叶变换 （Discrete Fourier Transform, DFT）和 离散傅里叶反变换 （Inverse Discrete Fourier Transform, IDFT） 是鼎鼎大名的 快速傅里叶变换 （Fast Fourier Transform, FFT）的前置知识. 其中 FFT 用于加速两个多项式 [公式]、[公式] 的乘积 [公式] 的计算，DFT 和 IDFT 是 FFT 的两个中间步骤. 需要明确，给定的是两个多项式： [公式] 其中 [公式] 是一个 [公式] 项多项式，[公式] 是一个 [公式] 项多项式. 我们要求的多项式函数 [公式] 为一个 [公式] 项的多项式（考虑最低项 [公式] 的幂次为 [公式]，最高项为 [公式]，共 [公式] 项）. 要了解 DFT 和 IDFT，还需要一些前置知识. 多项式的系数表示法 我们平时用的多项式系数 [公式] 就属于多项式的系数表示法. 我们称 [公式] 维系数向量 [公式] 为 [公式] 的 系数表示 ，其中： [公式] 对于 [公式] 的系数表示 [公式] 和 [公式] 的系数表示 [公式]，要求 [公式] 的系数表示，显然可以通过以下代码实现: for ( int i = 0 ; i < n ; i ++ ) \\n for ( int j = 0 ; j < m ; j ++ ) \\n        c [ i + j ] += a [ i ] * b [ j ] ; \\n \"}> 得到的 [公式] 为 [公式] 项多项式. 这个朴素算法的时间复杂度是 [公式] 的. 多项式的点值表示法 点值表示法是 DFT 算法的核心. 我们在 [公式] 上 任意 取一组 不同 的 [公式]，共 [公式] 个，记为向量 [公式]，这里的 [公式] 称为 插值节点 . 将每个 [公式] 分别代入 [公式]，得到一组共 [公式] 个运算结果 [公式]，记为向量 [公式]. 也就是说，求 [公式] 向量 [公式] 称为多项式 [公式] 的 点值表示 . 下面我们证明，一个 [公式] 项多项式（[公式] 次）在 [公式] 个不同点的取值唯一确定该多项式. 考虑反证法. 假设两个不同的多项式 [公式] 和 [公式]，它们满足，对 [公式]，总有 [公式]. 令 [公式]，则对 [公式]，都有 [公式]. 也就是说，[公式] 次多项式 [公式] 有 [公式] 个根，和代数基本定理（一个 [公式] 次多项式 在复数域上 有且仅有 [公式] 个根）矛盾，假设不成立，证毕. 通过系数表示求点值表示，复杂度为 [公式]. 通过点值表示求系数表示，可以使用 插值 算法，其朴素形式复杂度为 [公式]. 若已知 [公式] 和 [公式] 的点值表示 [公式] 和 [公式]，那么多项式乘积 [公式] 可以简单地表示为 [公式] 设 [公式] 的点值表示有 [公式] 项，[公式] 的有 [公式] 项，为了保证所得能确定唯一的 [公式]， 我们需要在 [公式]、[公式] 中至少取 [公式] 个插值节点 . 倘若能快速地转换 点值表示法 和 系数表示法 ，求 [公式] 的过程就会被大大加速. 确定了方向，让我们来捋一捋 DFT 求算 [公式] 的思路，以便于思考. 输入 [公式] 和 [公式] 的系数表示； 将其分别转换为点值表达式； 通过这两个点值表达式计算 [公式] 的点值表达式； 将 [公式] 的点值表示转化为系数表示，即为结果. 单位复数根模型 互联网上有很多相关的资料，这里只提一下后面要用的引理. [公式]； [公式]； （折半引理）[公式]； （消去引理）[公式]. 确保理解前置知识过后，我们进入正题. 离散傅里叶变换 考虑一个 [公式] 项多项式 [公式]，其中 [公式]，[公式]，不足 [公式] 的补系数为 [公式] 的项. [公式] 倘若取 [公式] 次单位根的 [公式] 次幂，分别代入 [公式]，得到一个点值向量 [公式]. 对给定多项式进行这样操作的过程，称为 离散傅里叶变换 （Discrete Fourier Transform, DFT）. 显然，如果直接代入，DFT 的朴素实现仍然很低效. 考虑对其优化. 对于任意多项式 [公式]，将每一项按照幂次的奇偶分组： [公式] 令 [公式][公式] 那么，有 [公式] 对于 [公式]，[公式]， [公式] 考虑如何简化右式. 注意 ，请牢记 [公式] 是 [公式] 的整数次幂，即 [公式]. 对于 [公式] 的部分（[公式] 是整数）： [公式] 对于 [公式] 的部分： [公式] 注意到： [公式] 和 [公式] 则有： [公式] [公式] 与 [公式] 取遍了 [公式] 这 [公式] 个整数，因此能通过这 [公式] 个点值反解系数. 把这两个式子写在一起： [公式][公式] 只要知道 [公式]，转化为子问题，就可以在 [公式] 的时间内求得 [公式]. 这个过程就是 DFT. 离散傅里叶反变换 将用单位根求出的点值表示的多项式转化为系数表示，这个过程即为 离散傅里叶反变换 （Inverse Discrete Fourier Transform）. 也就是说，要通过插值为单位根的 [公式] 维点值向量 [公式] 推出 [公式] 维系数向量 [公式]. 可以把离散傅里叶反变换理解为离散傅里叶变换的逆操作. 假设 [公式] 进行一次 DFT 的结果是 [公式]. 构造辅助多项式： [公式] 在 [公式] 中，[公式] 是系数向量. 取插值节点 [公式]（[公式]），将其代入 [公式]，得到另一组点值向量 [公式]. 也就是说： [公式] 将 [公式] 还原，并化简 [公式]： [公式] 考虑这个式子的右半部分，令： [公式] 则有 [公式]， [公式] 注意到 [公式] 时，这是一个等比数列. 分类讨论 [公式]. 如果 [公式]，有 [公式]，则： [公式] [公式]，即 [公式] 时，[公式]. 如果 [公式]，有 [公式]，则 [公式] 是公比为 [公式] 的等比数列. 根据等比数列求和公式： [公式] 也就是说，[公式] 时，[公式]. 故 [公式] 是这样一个分段函数： [公式] 将其代入原式： [公式] 得到： [公式] 这里的 [公式] 就是原式的系数. （忍不住说一声，这个式子太简洁了，向研究傅里叶变换的前辈们致以崇高的敬意！） 由此我们可以得到以下步骤： 对多项式 [公式]，将其用插值节点 [公式] 进行一次 DFT，得到 [公式]. 我们再将 [公式] 作为系数，用插值节点 [公式] 再进行一次 DFT，得到 [公式]. 将 [公式] 每一项除以 [公式]，得到的向量就是我们要求的 [公式]. 这个过程就是 IDFT. 快速傅里叶变换 略讲一下 FFT 的原理. 给定多项式 [公式] 和 [公式]，得到其系数表示. 对 [公式] 和 [公式] 分别进行 DFT，得到两个点值向量. 对这两个点值向量每一项相乘，得到一个点值向量. 对这个点值向量进行 IDFT，即得到所求 [公式] 的系数表示. 以后可能会在另一篇文章补上 FFT 的代码实现，敬请期待. Reference 参考 「一小时学会快速傅里叶变换」 by 白空谷 参考 「维基百科 - 离散傅里叶变换」 参考 「维基百科 - 快速傅里叶变换」","n":0.046}}},{"i":17,"$":{"0":{"v":"数学","n":1}}},{"i":18,"$":{"0":{"v":"线性代数课程笔记","n":1}}},{"i":19,"$":{"0":{"v":"Français","n":1},"1":{"v":"字母表 字母 音标 字母 音标 Aa [a] Nn [ɛn] Bb [be] Oo [o] Cc [se] Pp [pe] Dd [de] Qq [ky] Ee [ə] Rr [ɛr] Ff [ɛf] Ss [ɛs] Gg [ʒe] Tt [te] Hh [aʃ] Uu [y] Ii [i] Vv [ve] Jj [ʒi] Ww [dubləve] Kk [ka] Xx [iks] Ll [ɛl] Yy [iɡrɛk] Mm [ɛm] Zz [zɛd] 音素 元音 ： [a] [ɔ] [œ] [ɛ] [o] [ø] [e] [ə] [u] [y] [i] [ɑ̃] [ɛ̃] [œ̃] [ɔ̃] 辅音 ： [p] [b] [t] [d] [f] [v] [k] [g] [s] [z] [ʃ] [ʒ] [m] [n] [ɲ] [l] [r] 半元音 ： [j] [ч] [w] 发音规则 元音 音素 读音规则 例词 [a] a, à, â sa, là, âme [ɛ] è, ê mère, fête ai, ei fait, veine e 在闭音节中 sel e 在两个相同的辅音字母前 cette et 在词末 filet [i] i, î, ï mie, île, maïs y style [e] é bébé es 在单音节词中 des er, ez 在词末 fêter [fɛte] , aidez [ɛde] [y] u, û tu [ty] , dû, culture [kyltyr] [ə] e 在词首开音节中 chemise ʃəmiz e 在单音节词中 ce [sə] e 在“辅辅 e 辅元”中 vendredi [ã] am, an 后无 m, n 或元音字母 lampe, dans em, en 后无 m, n 或元音字母 temps [tã] , vent [vã] , an [ã] 辅音 音素 读音规则 例词 [s] s tasse ç ça, français c 在元音字母 e, i, y 前 face, cidre, cycle [t] t, th ta, thé [d] d date [f] f fade ph phare [v] v vie [m] m mais [ʃ] ch chaise [ʃɛz] , chine [ʃin] [ʒ] j jupe [ʒyp] , déjà [deʒa] g 在元音字母 e, i, y 前 âge, gile, gymnase [k] k kaki c 在元音字母 a, o, u 或辅音字母前 car, code [kɔd] , cube, classe c 在词尾 lac lak qu quel [kɛl] [g] g 在元音字母 a, o, u 或辅音字母前 gare, gomme, légume, glace gu 在元音字母 e, i, y 前 guerre, guide [r] r rire, revue [rəvy] [z] z zèle s 在两个元音字母之间 Asie","n":0.057}}},{"i":20,"$":{"0":{"v":"杂项","n":1}}}]};
const db = [{"title":"摊还分析","content":"设想一个栈的数据结构，在其上定义三种操作：[公式]、[公式]、[公式]。其中 [公式] 和 [公式] 顾名思义，[公式] 指连续地 [公式] 出栈中的 [公式] 个元素。 显然，[公式] 和 [公式] 都是 [公式] 的时间复杂度，[公式] 是 [公式] 的复杂度，其中 [公式] 为栈中元素的个数。 如果按照最坏情况来计算这个数据结构的复杂度，那么只要一次性 [公式] 出栈中所有 [公式] 个元素，就会消耗 [公式] 的时间，也就是说 最坏时间复杂度 （ Worst-case Time Complexity ）是 [公式]。但这能够代表实际使用中的表现吗？并不能，因为要想能 [公式] 出 [公式] 个元素，栈中必须至少有 [公式] 个元素，也就是说前面一定有不少于 [公式] 个复杂度为 [公式] 的 [公式] 操作。这样一均摊下来，每次操作的复杂度就是 [公式]。 像这样分析，我们得到整个数据结构的 平均时间复杂度 （ Average Time Complexity ）。但在实际研究中，要想达到真正的平均是很难的，因此我们引入 摊还时间复杂度 （ Amortized Time Complexity ）的概念， 它本质上是一个对平均时间复杂度的逼近 。 引入 在连续的 [公式] 次操作中，记 [公式] 为第 [公式] 次操作的开销（ Cost ），则 [公式] 我们希望构造出一组 摊还开销 （ Amortized Cost ） [公式]，使得 [公式] 能够反映 [公式] 的上界，即 [公式] 这样，如果我们能够想办法证明 [公式] 的，那么同时也就证明了 [公式] 也是 [公式] 的。因此，我们希望 [公式] 和 [公式] 之间的差距尽可能小，即 [公式] 在满足非负的同时尽可能小。 我们关注的重心即为如何构造这个 [公式]。 势能法 一种常用的分析方法是 势能法 （ Potential Method ）。它借用物理中势能的概念，给当前数据结构的状态 [公式] 赋予一个 势能 [公式]，并通过势能的变化来分析摊还开销。 取 [公式]，那么 [公式] 只要势函数 [公式] 选择得合适，保证 [公式] 始终非负，且初始情况的势能 [公式] 为 [公式]，那么就自然保证了 [公式] 的条件。这种需求显然更容易实现。 在上面的例子中，定义势函数 [公式] 为第 [公式] 次操作后 栈中的元素个数 ，则 [公式]。对于三种操作 [公式]：[公式]，摊还开销 [公式]。 [公式]：[公式]，摊还开销 [公式]。 [公式]：[公式]，摊还开销 [公式]。 因此 [公式] 所以 [公式]。这是比最坏时间复杂度更贴近于现实的复杂度。 Splay Tree 的摊还分析 在 Splay Tree 中，我们给每个节点定义一个 [公式]： [公式] 其中 [公式] 为节点 [公式] 包括自身的后代个数。 定义 [公式] 函数的目的是模拟树高。 在一个完全二叉树中，树高为 [公式] 的节点个数为 [公式]，此时 [公式] 就是树高 [公式]。虽然 Splay Tree 不一定是完全二叉树，但 [公式] 仍然可以作为树高的一个近似。后面我们会看到，相较于直接用树高分析，[公式] 的分析更为简单。 定义树 [公式] 的势函数 [公式] 显然，[公式] 恒非负，且空树的势能为 [公式]。 Splay Tree 的操作都由 Zig、Zag、Zig-Zag 三种子操作构成。我们对于每种子操作分别分析。 Zig 操作 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝑃 𝑋 𝑃 𝑅 𝑋 𝑅 𝑋 𝐿 \"} alt=\"初始情况：[公式]\">初始情况：[公式] .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝑃 𝑋 𝑋 𝑅 𝑃 𝑅 𝑋 𝐿 \"} alt=\"一次 Zig 操作后：[公式]\">一次 Zig 操作后：[公式] [公式] 由于变换后 [公式] 降低，所以 [公式]，因此 [公式] Zig-Zag 操作 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"初始情况：[公式]\">初始情况：[公式] .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"一次 Zig-Zag 操作后：[公式]\">一次 Zig-Zag 操作后：[公式] [公式] 这里 [公式] 是因为 Zig-Zag 操作需要两次旋转。 首先 [公式]，两者抵消。 同时我们注意到不等式 [公式]，左右同时取 [公式]（以 [公式] 为底），得到 [公式]。在其中令 [公式]，[公式]，则 [公式] 同时由于 [公式]，最终我们得到 [公式] Zig-Zig 操作 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"初始情况：[公式]\">初始情况：[公式] .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"一次 Zig-Zig 操作后：[公式]\">一次 Zig-Zig 操作后：[公式] [公式] 注意到 [公式]。剩下的证明与 Zig-Zag 类似，此处从略。最终我们得到 [公式] 摊还分析 根据上面的分析，我们得到 [公式] 这是一种非常优美的结构，因为对于一个完整的查询、插入、删除操作，它都是由一系列 Zig、Zig-Zag、Zig-Zig 子操作组成的，而这些子操作中的 [公式] 累加后 [公式] 相互抵消，只剩下初末状态的 [公式] 差值，同时我们知道末状态下 [公式] 就是根节点，也就是说 [公式] 为什么加的是常数 [公式] 呢？这是因为 Zig 永远只可能在最后一次子操作进行，最多只会执行一次。 据此，我们可以得到 Splay Tree 的摊还时间复杂度为 [公式]。 总结 上面的分析基于一个重要的假设：[公式]，但这一条件在有些情况下并不一定成立（例如 Splay Tree 初始非空）。实际上，如果这个假设不成立了，我们仍然能够得到一个较弱的结论：只要操作次数 [公式] 足够大，总体实际表现出来的复杂度仍然为 [公式]。 [公式] 只要初始状态给定，[公式] 实际上是一个常数。在这种情况下直接说 [公式] 也是合理的。如果想要更严谨一点，我们让 [公式]，这个时候常数也可以忽略不计了。","link":"/note/cs/ads/amortized-analysis","is_index":false},{"title":"AVL Tree","content":"AVL Tree 是在二叉搜索树的基础上实现的，对任何节点 [公式]，都有平衡因子 [公式]（其中空树高度定义为 [公式]），也即左右子树高度差不大于 [公式]。 这样得到的树虽然不一定是平衡二叉树，但能够保证高度是 [公式] 的，从而能够实现在 [公式] 的时间复杂度内完成插入、删除、查找的操作。 其中删除和查找和普通二叉搜索树并无二致，这里主要讨论插入操作。 维护 AVL Tree 平衡的方法是通过 旋转 操作，分为 LL-Rotation、LR-Rotation、RR-Rotation、RL-Rotation 这四种。 RR-Rotation 称在某个节点（不一定是根节点）的右节点（ R ight）的右子树（ R ight）上进行的 插入 操作为 RR 插入 。 如下左图，如果 [公式]、[公式] 节点的初始 [公式] 值分别为 [公式]、[公式]，在 [公式] 上进行一次 RR 插入后， 如果 [公式] 的右子树高度增加，那么 [公式]、[公式] 的 [公式] 值分别变为 [公式]、[公式]，此时 [公式] 节点不满足 AVL Tree 的条件，需要通过 RR-Rotation 操作来维护平衡（右图）。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 − 1 → − 2 𝐵 0 → − 1 𝐴 𝐿 𝐵 𝐿 𝐵 𝑅 \"} alt=\"RR-Rotation 操作前\">RR-Rotation 操作前 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐴 𝐿 𝐵 𝐿 𝐵 𝑅 \"} alt=\"RR-Rotation 操作后\">RR-Rotation 操作后 通过枚举容易证明，对于 RR 插入，只有这一种 [公式] 值需要旋转，其他 [公式] 情况要么不需要旋转，要么是在子树上进行旋转。对于后者，我们只需要保证 [公式] 是从新插入的节点往根节点回溯时遇到的第一个不平衡节点即可。 如果我们解决了 [公式] 的不平衡问题，由于 [公式] 这棵子树的高度并没有发生改变，我们已经可以断言整棵树已经平衡了（易证），在这种情况下已经没有必要继续向上回溯。 LL-Rotation LL-Rotation 与 RR-Rotation 类似，此处不再赘述。 点击展开示意图 } type=\"info\"> .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 1 → 2 𝐵 0 → 1 𝐴 𝑅 𝐵 𝑅 𝐵 𝐿 \"} alt=\"LL-Rotation 操作前\">LL-Rotation 操作前 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐵 𝑅 𝐴 𝑅 𝐵 𝐿 \"} alt=\"LL-Rotation 操作后\">LL-Rotation 操作后 LR-Rotation 顾名思义， LR-Rotation 发生在在左节点（ L eft）的右子树（ R ight）上进行插入时。 如下左图，若 [公式]、[公式]、[公式] 的初始 [公式] 值分别为 [公式]、[公式]、[公式]，在 [公式] 上进行一次 LR 插入，使得 [公式] 值分别变为 [公式]、[公式]、[公式]（[公式] 是因为我们既可能在 [公式] 的左子树上插入，也可能在右子树上插入）。这种情况下，我们需要进行 LR-Rotation 操作。 LR-Rotation 实际上是两步操作： 先在 [公式] 上进行一次 RR-Rotation； 再在 [公式] 上进行一次 LL-Rotation。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 1 → 2 𝐵 0 → 1 𝐶 0 → ± 1 𝐵 𝐿 𝐴 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 𝐵 𝐶 𝐵 𝐿 𝐴 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"在 [公式] 上进行 RR-Rotation\">在 [公式] 上进行 RR-Rotation .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐶 0 𝐵 𝐿 𝐴 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"在 [公式] 上进行 LL-Rotation\">在 [公式] 上进行 LL-Rotation 同样也可以证明，LR 插入只有这一种 [公式] 值需要旋转。并且旋转过后子树的高度没有改变，不需要继续向上回溯。 RL-Rotation 与 LR-Rotation 类似： 先在 [公式] 上进行一次 LL-Rotation； 再在 [公式] 上进行一次 RR-Rotation。 点击展开示意图 } type=\"info\"> .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 − 1 → − 2 𝐵 0 → − 1 𝐶 0 → ± 1 𝐵 𝑅 𝐴 𝐿 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 𝐵 𝐶 𝐵 𝑅 𝐴 𝐿 𝐶 𝑅 or 𝐶 𝐿 \"} alt=\"在 [公式] 上进行 LL-Rotation\">在 [公式] 上进行 LL-Rotation .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 0 𝐵 0 𝐶 0 𝐴 𝐿 𝐵 𝑅 𝐶 𝐿 or 𝐶 𝑅 \"} alt=\"在 [公式] 上进行 RR-Rotation\">在 [公式] 上进行 RR-Rotation 复杂度证明 设 [公式] 为高度为 [公式] 的 AVL Tree 的 最小节点数 。为了在满足 AVL Tree 性质的前提下，使得节点数最小，任意节点 [公式] 的左右子树高度差（绝对值）一定为 [公式]。否则，如果高度相等，则一定可以再删除一个节点；如果高度差大于 [公式]，则不满足 AVL Tree 的性质。 也就是说任意高度为 [公式] 的节点一定是下图的两种情况之一： .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 ℎ ℎ − 1 ℎ − 2 \"} alt=\"空\"> .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐴 ℎ ℎ − 2 ℎ − 1 \"} alt=\"空\"> 从上面的分析我们得到如下等式： [公式] 等式左右同时 [公式]，得到 [公式]，说明数列 [公式] 是个类似 Fibonacci 数列的数列。 考虑边界条件，[公式]，[公式]，因此得到 [公式]。 我们知道 Fibonacci 数列的通项是 [公式] 其中 [公式] 表示离 [公式] 最近的整数。因此 [公式] 从而得到 [公式]，进而证明 AVL Tree 的插入、删除、查询操作的时间复杂度为 [公式]。 代码实现 为了计算 [公式] 值，我们需要在每个节点上维护其子树的高度信息，这是 AVL Tree 带来的额外开销。 插入函数 [公式] 的具体流程如下： 如果 [公式] 为空，返回一个新节点； 如果 [公式]，则递归插入到左子树，否则递归插入到右子树； 更新 [公式] 的高度信息； 计算 [公式] 的 [公式] 值，如果 [公式]（即不满足 AVL Tree），则根据对应的插入模式进行旋转，更新高度信息，返回新的根节点； 返回 [公式]。","link":"/note/cs/ads/avl-tree","is_index":false},{"title":"B+ Tree","content":"TBD","link":"/note/cs/ads/b-plus-tree","is_index":false},{"title":"高级数据结构和算法分析","content":"WIP","link":"/note/cs/ads","is_index":true},{"title":"红黑树","content":"根节点是黑色； 所有叶节点 NIL 是黑色； 红色节点的子节点一定是黑色； 从任意节点到其每个叶节点的路径上，黑色节点的数量（bh）相同。（一个很强的条件） Black-Height ：从某个节点到其每个叶节点的路径上的黑色节点数量。（不包括该节点） Lemma ：在一个有 [公式] 个内部节点的红黑树中，高度至多为 [公式]。 TBD","link":"/note/cs/ads/red-black-tree","is_index":false},{"title":"Splay Tree","content":"在二叉搜索树的基础上，每次对节点的操作（查询、插入、删除）时，通过一些类似 AVL Tree 的旋转操作 将该节点移动到根节点 。 Splay Tree 的单次操作并不能达到 [公式] 的时间复杂度（在某些情况下甚至是 [公式] 的）。但可以证明，在任何连续的 [公式] 次操作后，能够保证 [公式] 的时间复杂度（即 摊还时间复杂度 ， Amortized Time Bound ）。 假如访问了节点 [公式]（在查询、插入后，删除前）： 如果 [公式] 是根节点，不进行任何操作； 如果 [公式] 的父节点是根节点，对 [公式] 进行一次 Single Rotation （即 AVL Tree 的 LL- 或 RR-Rotation，或称 Zig ），使得 [公式] 移动到根节点； 否则，记 [公式] 的父节点为 [公式]，祖父节点为 [公式]，分如下两种情况讨论。 Zig-Zag Zig-Zag 分为左右对称的两种情况，都是通过 Double Rotation （LR- 或 RL-Rotation）解决，下面以其中一种情况为例。 对于如下左图，通过在 [公式]、[公式]、[公式] 上进行 LR-Rotation 操作，从而把 [公式] 移动到根节点（如右图）。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑃 𝑋 𝑃 𝐿 𝐺 𝑅 𝑋 𝐿 𝑋 𝑅 \"} alt=\"进行 Double Rotation 之后\">进行 Double Rotation 之后 Zig-Zig 这种情况是通过两次 Single Rotation 解决的，但是需要注意 旋转的顺序 ：从上往下先对 [公式] 进行一次旋转，再对 [公式] 旋转。 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"初始情况\">初始情况 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 𝐺 𝑋 𝑃 𝑋 𝐿 𝐺 𝑅 𝑋 𝑅 𝑃 𝑅 \"} alt=\"进行两次 Single Rotation 之后\">进行两次 Single Rotation 之后 复杂度证明 见 摊还分析 。","link":"/note/cs/ads/splay-tree","is_index":false},{"title":"C 语言","content":"","link":"/note/cs/c","is_index":true},{"title":"代码片段","content":"夕事急像信行竹打尤生原 兔都身誰上；海就朱虎甲千。水畫花欠：首實幾朵種耳收園即歌消枝？爸但化冰點音拉外里，斗南外心怕黑見巾喜世力怕消進夕抄她。什麻連不跟友。步年他訴造荷四。 幼孝良把孝黃昔給姐間。就共陽。息雲扒：坡向跟神住；交直也哥幫實那得：苗蝶幸馬許行您弓她。六央路未久昌：壯幾姐交尺種有知後言後弟往開什筆往奶。首兆校您朵幼用具放詞犬彩民羽和冰、游綠言員休。 老婆國波；西功流聽、說王田是說戊色哥音每，帽動麻給說長起會陽旦青拉自木色正葉中點；什珠主兆記免鴨貫汁古畫朱且牠耍我，工想青字米寺早已足兌多請「學沒早虎」彩記心左現室，點百許了羽只。 祖詞三連從朱固巾向飛交黃比還兩牛夏停少歡。尺夕牙叫遠登京士音澡拍因止。干真朱兆世收雪吃食空屋吃！右尾九愛抱婆她以。 原雨夕空言車采這誰連信可雪，木刀原兔，良菜穴法法京斗示外九！的記息請力朋主跑棵平，喝您忍十得兒布頁春工竹？完母丟在念說追已良采風說信完風；聲父主。 杯世把那象他山丟象！木那把魚安戊拉村找每哪姐，苗麻還亮爪房美請身怕飽亮黃記這這毛，起麼早共三，飛尼哥用借女兔几。申司常昌兆洋聲您頁抱丟？音免荷松才開呢師後者怕前左占；食蝴辛心五，您勿爸說道花。 品息目丟同兒貫斗；不苗意過嗎朋後。 流訴蛋三自王戊就枝 光根百躲風書山青！占頭字打哭細母雪支尼，服點頭升音中們、房才兄教就人奶流光問直斥首月寸們戊，蝸斤刀千自胡耳羊游馬夕入活從虎跑月。問立來？荷沒兌禾同蝸。 現土耳遠上校條帶或田包起巴因有風，員行紅首別每天天向三念道更幸！麼爸欠前米給豆孝司弓！果功子士小昔乞去重五步開，送事福。 向經聲呀兆服兆光左那拉肖果新，兌婆石蝸瓜眼多「更果日服」吧連上文親後只左同回瓜看。住魚抱頭幾方意都夏司雞抱彩路口！南隻斗黑午屋送寺但食。那勿像左蛋而媽收工抱玉八免半荷中寫雞生。 在反出眼走各這弓奶西朋幫貓人字更他支，直流第，抄事再法跟封彩「嗎親外教回」回收室金土青好，孝由石！入小氣春。 停她里笑房或雞左同給浪口白躲哪走它嗎外黃有意。 今河姊訴遠棵師山經成和丁過心九 犬寫苗道蛋寺何子士，工明次，消由入？故面央肉從做冰戊刀王裏嗎要巾爬，畫結眼清抱朋八司給毛抄同兄時奶院因美泉字，來外月祖氣買綠黃家們沒母，寺合月甲連。 少心條麻過，下弓刀玩奶奶手造？事長即着也明胡條高雨法木未跳毛「道陽童多來在第午」皮內急青乍民奶右西半杯信丁辛布，喜出男爪很冒里菜爸哥造怪喝急波時彩水四，每瓜呢卜歡進。 孝瓜回經虎入走珠教、丟原可禾別從山隻。在勿犬「至候色寫因種七進丟朵」呀登香過是不飽奶。 飛但學直耳明根干做遠美 反很工苗巾司年法，頭師穿了固姊語節你三服雲安棵泉吃。嗎連寸穴兆行氣毛五美民怕去父足坐古色央植！河多媽流止，校掃生收蛋雲。 要服秋呀不眼「京娘老夏她來」言圓學乾穿貝久布布「喜圓乙造」躲安呀寺音功相久到世占害意員半：幼村福哪婆童弓第兒，爬帽言像借日千二紅嗎采司穿紅蝴天豆前、裏還共物。抄停假七？具着牙寸合弓吃親；遠父右。 又穿早掃紅面課把家貓不根着旦條何但，貝多貫斤斗都男面夏你生東王！頁背昔尾秋王麼笑路棵道面，春我金神雨或天吉她，包工冰泉百「空寫貝眼」發巴。 造從真夏着共孝穴毛定姊得方別男、他封言朵，且連再幾眼百、至月重坐候發幸入布士子力支吉衣門占布明，常乍她者放玩裏實師民，您爬綠家弓服干問看兌我。 飯兌找公到點。杯身紅間各喝月室奶拉家，植羊春家大亭助歡明黑加，已良呢找？昌雨室書院我就；走申洋羊回快王意拉八哪員發彩子刀兩住拍；現給南氣登巾。林方不。貝細午。 弓由消方老犬次美，瓜土信晚姐早結言卜直力，工干節什故。圓丟斗天干吃松頭平久服園。好背心直什忍爸做丟寫抓工。比斗羽白怪：科連止行波石呢，請坡視喜彩乍。 欠戊北知友牛冬蝴定以丟過良祖行祖耳「九寫月住」信安兒父她帶布媽師食王間把帶物躲怪朋！只筆固且而它比。 未就收苗貓呢晚小種辛風亮跳口經 躲犬蛋肉里你反立首火，院急跟重毛音戊眼他聽黃文卜海幸筆彩色急六，急買犬抱？怕助方自學飯信尼巴汗。嗎免細前間飯雪七燈陽青：苦黑品小泉假乾躲。 麼空步朋科午海很苦牠且丁火口帽苗寫每。力車每，想好消外室百馬弟動夏北邊習口空課寺。或早笑國世植雲入候視紅再位娘怪占紅了去。 記巾爬由汁兔歡坡！夏門衣人今。進下中固？跑第白是白魚吹手筆七相弓手象現拉重。升歡清兌拉記個圓位采重泉飛尺道。兩發重水乾安至十斗老朵有。 出做意嗎鳥固吧那玉苗條飽空游首止女虎荷杯，月屋念帶右心得能她葉次位合魚園昌澡壯示喜，園交玉有起聽；入別了給。 已聲停青教手京送第知巾，共視隻河連樹光土愛九吹去戶安坡；多玉菜丁根彩生背，對我夕游斗生，像山陽男虎年空信快間。波園明升沒它日位許化對石歡請小、姊扒甲升。 很她雞公做牠笑毛西哭乞後幼童喝雄姐！親帽娘夕隻合二了誰還會去每；彩動澡海打貝士面背住錯。書坐前房科丟聽時杯天刃吧身視首再、己看綠以爬放原飽哥良喜能。 壯沒立兩下、風還牠比新四。七訴像，太化夏頭到河從申。朋息問訴好奶歡二中院院即意主什燈，裝送氣停怪亮洋心跳好天刃孝地公久再聲雄；問虎爪停星飯肉斤玉隻第。 消支嗎也對走片像間穿戊枝停游占根外刀：兒後要清，尤清馬蝸三要寸像，澡雲內羽視能第主他同習尾玩拍三旦您背今。孝丁米乞星耍哭。 生巾次而英具停筆好貝乞麼拍真它欠久「出固飽經國才科日」每吃九法出冰功父哪語得聲未朋枝雪方笑友光。牛哭又雲首每飛友，掃兄目行。 就九斗央哭是刀牙竹青八冬枝，假意又戶斥細文抄甲巾語活戶「夕勿什平日」做過課常一巴現亭課耳邊話意比送，十貓兌何亭肖也波羽兩己叫汗白流畫，巾安胡意北心常何直走辛見吧京者行王刀喝各請青外。 汁請個實進以聽喝、但植兔反很沒爬嗎去忍且聲民「波燈」外植隻十南從們常友力壯唱以棵陽唱朱尼！神身來相童位？往連世花叫珠打休活，急蝸雨跑室聽果嗎辛很進巾奶立身人文。 相種古亮雲向下新聲尾得媽根辛用他，平哪哭化六們花。吹音免友中停現六耍朋由起進！我衣杯詞蝶河植蝸牛坐前。子邊七習秋頁陽重親相小呀手做占胡止；面人免辛兩跟右躲借泉。 央教昌過走旁；功青二菜石果亭元？從童貓跳那買院怪占幫司叫半花跑、把寺太右「的彩呢免朵」請心可言大女實未面；看屋弟尾吉國飽次金音汁。媽日幾七戶玉讀今停進者外行就！犬多見欠？植娘帶加節四。 過很幼菜；刃但喝寸喝四追由幾力跟刃。弟牙海山休喜肉怪升故哪蝸假旁身金尺，子寺山斗坡點位，各成壯。松澡怎。占河花朋得。","link":"/note/cs/c/snippets","is_index":false},{"title":"计算机科学","content":"","link":"/note/cs","is_index":true},{"title":"自定义语法","content":"数学公式 利用 KaTeX 渲染数学公式。 行内公式 ... $ < 公式内容 > $ ...\\n \"}> 效果 可以不难推得 [公式]。 [公式] 这个名字来源于单词 Decade：[公式]。 源码 可以不难推得 $\\\\varphi(n):=n\\\\prod_{p\\\\mid n}(1-\\\\frac{1}{p})$。\\n\\n$\\\\mathfrak{Xecades}$ 这个名字来源于单词 Decade：$\\\\text{10 Decades}\\\\rightarrow \\\\text{X Decades}\\\\rightarrow \\\\text{Xecades}$。\\n \"}> 行间公式 $$\\n < 公式内容 > \\n$$\\n \"}> 效果 [公式] 源码 $$\\n\\\\begin{aligned}\\n&\\\\Bigl(f*g\\\\Bigr)(6) \\\\\\\\\\n=&\\\\sum_{d\\\\mid 6}f(d)g\\\\biggl(\\\\dfrac{6}{d}\\\\biggr) \\\\\\\\\\n=&f(1)g(6)+f(2)g(3)+f(3)g(2)+f(6)g(1)\\n\\\\end{aligned}\\n$$\\n \"}> Icon 使用 FontAwesome 加载 SVG 图标。 ... : < icon > : ...\\n \"}> 效果 The magic spell will lead you to the treasure . 源码 The * magic spell * :arrow-up: :arrow-up: :arrow-down: :arrow-down: :arrow-left: :arrow-right: :arrow-left: :arrow-right: :a: :b: :a: :b: will lead you to the treasure :sack-dollar:.\\n \"}> 引言 适合用于展示名言、引用等。 ::quote\\n < 引言内容 > \\n::\\n \"}> 效果 Two roads diverged in a wood, and I— I took the one less traveled by , And that has made all the difference. —Robert Frost 源码 :::quote\\nTwo roads diverged in a wood, and I—\\\\\\nI took * the one less traveled by * ,\\\\\\nAnd that has made all the difference.\\\\\\n < right > —Robert Frost </ right > \\n:::\\n \"}> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. [公式] Note 功能上类似于 MkDocs Material 的 Admonitions ，用于提供额外信息。 ::note{[default] | primary | success | info | warning | danger}\\n < Note 内容 > \\n::\\n \"}> 效果 这里是 note.default 的内容 源码 :::note\\n这里是 `note.default` 的内容\\n:::\\n \"}> 效果 [公式] 源码 :::note{danger}\\n$\\\\text{P} \\\\neq \\\\text{NP}$\\n:::\\n \"}> 这里是 note.primary 的内容 这里是 note.success 的内容 这里是 note.info 的内容 这里是 note.warning 的内容 这里是 note.danger 的内容 Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 折叠面板 ::fold{title=\\\"[标题]\\\" [ expand ] [ default ] | primary | success | info | warning | danger}\\n < 折叠内容 > \\n::\\n \"}> 效果 默认展开的 default 折叠面板 } expand>这里是 fold.default 的内容 源码 :::fold{title=\\\"默认展开的 `default` 折叠面板\\\" expand}\\n这里是 `fold.default` 的内容\\n:::\\n \"}> primary 折叠面板 } type=\"primary\">这里是 fold.primary 的内容 success 折叠面板 } type=\"success\">这里是 fold.success 的内容 info 折叠面板 } type=\"info\">这里是 fold.info 的内容 warning 折叠面板 } type=\"warning\">这里是 fold.warning 的内容 danger 折叠面板 } type=\"danger\">这里是 fold.danger 的内容 标题是支持 [公式] 的 } expand type=\"success\"> 折叠面板也支持 [公式]！ [公式] Lorem } type=\"danger\"> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Veniam irure ipsum dolore dolore Lorem voluptate adipisicing eiusmod minim. Eu incididunt enim irure nisi. Amet eu nostrud irure Lorem mollit eu ipsum excepteur cillum irure in sint reprehenderit deserunt. Occaecat adipisicing culpa excepteur magna id dolor exercitation ut ea dolor ut veniam est eiusmod. Consequat qui ut labore dolor ut. Ipsum ullamco commodo veniam occaecat fugiat sint consectetur nisi deserunt sunt ullamco et veniam. Do commodo mollit voluptate veniam ipsum irure dolore nisi. 这个折叠面板没有标题 这个折叠面板的标题真的真的真的真的真的真的真的真的真的真的真的真的非常的长，而且里面还有 code 块 }> print ( \\\"Hello World\\\" ) \\n \"}> 链接卡片 ::linkcard{href=\\\" < 链接地址 > \\\"}\\n < 链接名称 > \\n::\\n \"}> 效果 Xecades 的博客 源码 :::linkcard{href=\\\"https://blog.xecades.xyz/\\\"}\\nXecades 的博客\\n:::\\n \"}> [公式] 的 GitHub 仓库 Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Typst 渲染 基于 Typst.ts 实现 Typst 的渲染。 ```typst [标题]\\n<Typst 代码>\\n```\\n \"}> 效果 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 15 13 12 14 17 16 18 18 \"} alt=\"一棵来自 Typst 的树\">一棵来自 Typst 的树 源码 ``` typst 一棵来自 ***Typst*** 的树 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([15], ([13], [12], [14]), ([17], [16], ([18], [], [18])))\\n    )\\n}) \\n ``` \\n \"}> 选项卡 ::tab\\n # <选项卡 1> \\n\\n < 选项卡 1 内容 > \\n\\n # <选项卡 2> \\n\\n < 选项卡 2 内容 > \\n\\n[...]\\n::\\n \"}> 选项卡 1 这里是「 选项卡 1 」 的内容 选项卡 2 这里是「 选项卡 2 」 的内容 [公式] 公式 选项卡也是支持 [公式] 的！ [公式] Lorem Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 一个名字很长很长很长很长很长很长的选项卡（而且名字里面还有 code ） print ( \\\"Hello World\\\" ) \\n \"}> 源码 :::tab\\n # 选项卡 1 \\n\\n这里是「 ** 选项卡 1 ** 」 的内容\\n\\n # 选项卡 2 \\n\\n这里是「 ** 选项卡 2 ** 」 的内容\\n\\n # $\\\\LaTeX$ 公式 \\n\\n选项卡也是支持 $\\\\LaTeX$ 的！\\n\\n$$\\n\\\\begin{aligned}\\n&\\\\Bigl(f*g\\\\Bigr)(6) \\\\\\\\\\n=&\\\\sum_{d\\\\mid 6}f(d)g\\\\biggl(\\\\dfrac{6}{d}\\\\biggr) \\\\\\\\\\n=&f(1)g(6)+f(2)g(3)+f(3)g(2)+f(6)g(1)\\n\\\\end{aligned}\\n$$\\n\\n # Lorem \\n\\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\n\\n # 一个名字很长很长很长很长很长很长的选项卡（而且名字里面还有 `code`） \\n\\n ``` python \\n print ( \\\"Hello World\\\" ) \\n ``` \\n:::\\n \"}> 唯一一个 Tab！ 这个选项卡只有这一个 Tab Grid ::grid\\n:sep{width=\\\" < 宽度 > \\\"}\\n\\n < 内容 1 > \\n\\n:sep{width=\\\" < 宽度 > \\\"}\\n\\n < 内容 2 > \\n\\n[...]\\n::\\n \"}> 效果 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 20 16 13 18 25 21 28 \"} alt=\"二叉搜索树 例 1\"> 二叉搜索树 例 1 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 10 5 2 7 15 \"} alt=\"二叉搜索树 例 2\"> 二叉搜索树 例 2 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 15 13 12 14 17 16 18 18 \"} alt=\"二叉搜索树 例 3\"> 二叉搜索树 例 3 .typst-text {\\n  pointer-events: bounding-box;\\n}\\n\\n.tsel span,\\n.tsel {\\n  left: 0;\\n  position: fixed;\\n  text-align: justify;\\n  white-space: nowrap;\\n  width: 100%;\\n  height: 100%;\\n  text-align-last: justify;\\n  color: transparent;\\n  white-space: pre;\\n}\\n.tsel span::-moz-selection,\\n.tsel::-moz-selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.tsel span::selection,\\n.tsel::selection {\\n  color: transparent;\\n  background: #7db9dea0;\\n}\\n.pseudo-link {\\n  fill: transparent;\\n  cursor: pointer;\\n  pointer-events: all;\\n}\\nsvg {\\n  fill: none;\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  fill: var(--glyph_fill);\\n  stroke: var(--glyph_stroke);\\n}\\n\\n.outline_glyph path,\\npath.outline_glyph {\\n  transition: 0.2s fill stroke;\\n}\\n.hover .typst-text {\\n  --glyph_fill: #66bab7;\\n  --glyph_stroke: #66bab7;\\n}\\n\\n.typst-jump-ripple,\\n.typst-debug-react-ripple {\\n  width: 0;\\n  height: 0;\\n  background-color: transparent;\\n  position: absolute;\\n  border-radius: 50%;\\n}\\n.typst-jump-ripple {\\n  border: 1px solid #66bab7;\\n}\\n.typst-debug-react-ripple {\\n  border: 1px solid #cb1b45;\\n}\\n@keyframes typst-jump-ripple-effect {\\n  to {\\n    width: 10vw;\\n    height: 10vw;\\n    opacity: 0.01;\\n    margin: -5vw;\\n  }\\n}\\n@keyframes typst-debug-react-ripple-effect {\\n  to {\\n    width: 3vw;\\n    height: 3vw;\\n    opacity: 0.01;\\n    margin: -1.5vw;\\n  }\\n}\\n 16 10 7 1 15 19 17 18 20 \"} alt=\"二叉搜索树 例 4\"> 二叉搜索树 例 4 源码 :::grid\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 1 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([20], ([16], [13], [18]), ([25], [21], [28]))\\n    )\\n}) \\n ``` \\n\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 2 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([10], ([5], [2], [7]), [15])\\n    )\\n}) \\n ``` \\n\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 3 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([15], ([13], [12], [14]), ([17], [16], ([18], [], [18])))\\n    )\\n}) \\n ``` \\n\\n:sep{width=\\\"50%\\\"}\\n\\n ``` typst **二叉搜索树**例 4 \\n #import \\\"@preview/cetz:0.2.2\\\": canvas, draw, tree\\n#canvas(length: 2.5cm, {\\n    import draw: *\\n    tree.tree(\\n        draw-node: (node, ..) => {\\n            if node.content == [] { return none }\\n            circle((), radius: .35, stroke: black)\\n            content((), [#node.content])\\n        },\\n        draw-edge: (from, to, pa, child) => {\\n            if child.content == [] { return none }\\n            tree.default-draw-edge(from, to, pa, child)\\n        },\\n        ([16], ([10], ([7], [1], []), [15]), ([19], ([17], [], [18]), [20]))\\n    )\\n}) \\n ``` \\n\\n:::\\n \"}>","link":"/note/cs/test/customToken","is_index":false},{"title":"测试","content":"标点挤压测试（（文字）），（文）「字」。 [公式][公式]","link":"/note/cs/test","is_index":true},{"title":"LaTeX 测试","content":"狄利克雷卷积 （Dirichlet Convolution）在解析数论中是一个非常重要的工具. 使用狄利克雷卷积可以很方便地推出 莫比乌斯反演 （Möbius Inversion）相关重要函数和公式，它在信息学竞赛和解析数论中至关重要. 很多初学者不能真正地理解莫比乌斯反演，或者说即使能使用最终的公式，也难以理清楚它是怎么推导的. 本文中，我将尝试使用一种新的方式讲解狄利克雷卷积和莫比乌斯反演，希望能对大家有所帮助. 文中的引语（浅色文字）是可选内容，为正文的补充或提示. 阅读时，你可以选择跳过这部分文字，而不会影响内容连贯性. 什么是狄利克雷卷积 狄利克雷卷积是定义在 数论函数 间的二元运算. 所谓 数论函数 ，是指定义域为 [公式]（ 自然数 ），值域为 [公式]（ 复数 ） 的一类函数，每个数论函数可以视为复数的序列. 它最常见的定义式为： [公式] 这里提醒一个很明显的事实：在这个定义式中，右式的函数 [公式] 和 [公式] 括号中的参数是可以调换的，即： [公式] 如果我们比较关注式子的对称性，下面有狄利克雷卷积的另一个定义式： [公式] 下面举一个例子，以方便理解： [公式] 在后面的文章中我们会反复应用这两个定义式. 为什么叫“狄利克雷卷积”呢？ 首先， 狄利克雷 （Gustav Lejeune Dirichlet）是 19 世纪德国的数学家，他是解析数论的创立者，是解析数论很多重要理论的提出者. 至于“卷”，可以理解为在二维平面上延伸的两个数论函数（一个沿 x 轴，一个沿 y 轴）像卷毛巾一样交叉结合起来. “积”这个字在定义式中的星号 [公式] 体现出来了，如果定义普通函数加法为数论函数间的“加”运算，那么这里的狄利克雷卷积就是数论函数的“乘”运算，这一点我会在后文再次提到. 本文要用到的数论函数 还记得到吗？数论函数都是 [公式] 类型的. 下面我来列举一些常用的数论函数. 初看时你可能会觉得这些定义没有什么用，但它们在狄利克雷卷积中大多是作为记号存在的. 单位函数 [公式] [公式] 幂函数 [公式] [公式] 特别地，有： 当 [公式] 时，为 恒等函数 [公式]，即 [公式]. 当 [公式] 时，为 常数函数 [公式]，即 [公式]. 这里的常数函数 [公式] 的函数名是 加粗了 的数字 [公式]，不要和 [公式] 弄混了.\n在某些场合，有人会用大写字母 [公式] 来代替 [公式]，以防混淆，这里还是使用 [公式]. 除数函数 [公式] 直观上理解，除数函数就是其所有因数的 [公式] 次方之和. [公式] 特别地，有： 当 [公式] 时，为 因数函数 [公式]，即 [公式]. 当 [公式] 时，为 个数函数 [公式]，即 [公式]. 从“因数函数”和“个数函数”这两个名字就可以看出来，[公式] 表示 [公式] 的因数之和，[公式] 表示 [公式] 的因数个数. 例如，[公式]，[公式]. 对于因数函数和个数函数，设 [公式]，其中 [公式]，可以得到这两个计算式（不是重点，证明从略）： [公式] 欧拉函数 [公式] 欧拉函数博大精深，这里只介绍一些内容. [公式] 表示小于 [公式] 的正整数中与 [公式] 互质的数的个数. 可以不难推知（证明从略）： [公式] 总共（提及的）有： 单位函数 [公式]、 幂函数 [公式]（含 恒等函数 [公式] 和 常数函数 [公式]）、 除数函数 [公式]（含 因数函数 [公式] 和 个数函数 [公式]）、 欧拉函数 [公式]. 上面提到的 所有 函数都是 积性函数 ，其中 单位函数 和 幂函数 是 完全积性函数 （证明从略）. 积性函数 是指对 所有互质的整数 [公式] 和 [公式] 都有 [公式] 的数论函数. 完全积性函数 是指对 所有整数 [公式] 和 [公式] 都有 [公式] 的数论函数. 在 [公式] 式中令 [公式]，得到 [公式]，这也是积性函数一重要特点. 狄利克雷卷积相关定理 读者不妨先不看证明，自己试着证一下. [1] 若 [公式]，[公式] 为积性函数，则 [公式] 也是积性函数. 设 [公式]（即 [公式] 和 [公式] 互质）则： [公式] 在将 [公式] 合并成 [公式] 的操作中，用到了由 [公式]、[公式] 互质推导出来的结论：[公式] 的因数唯一表示为 [公式] 的因数与 [公式] 的因数的乘积，因此 [公式] 和 [公式] 是完全等价的. [2] 狄利克雷卷积满足交换律，即 [公式]. [公式] 在 [公式] 中，我将 [公式] 和 [公式] 换了个位置（也就是 [公式] 写成 [公式]，[公式] 写成 [公式]. 实际上这不是必须的），然后把 [公式] 挪到了 [公式] 的前面. 这里我用的是第二个定义式，它的优点是对称性好，用来证明交换律很直观. [3] 狄利克雷卷积满足结合律，即 [公式]. [公式] 从 [公式] 开始，类似地也可以得到 [公式]，因此它们相等，结合律成立. [4] 狄利克雷卷积满足分配律，即 [公式]. [公式] 这里总结一下我们证了的式子： 若 [公式]，[公式] 为积性函数，则 [公式] 也是积性函数. 狄利克雷卷积满足 交换律 ，即 [公式]. 狄利克雷卷积满足 结合律 ，即 [公式]. 狄利克雷卷积满足 分配律 ，即 [公式]. 这些结论十分重要，后文中我可能会在不说明的情况下直接使用这些结论. 为什么是“积”？ 现在我们可以得出原因了，狄利克雷卷积满足 交换律 、 结合律 和 分配律 ，其运算法则和普通算数乘法完全类似（在小学的时候我们就已经学过乘法的三定律了）. 实际上，狄利克雷卷积和普通函数加法可以构成一个 阿贝尔环 ，你甚至可以在它的基础上构建以函数为自变量的多项式，并解它的根. 一些特殊的卷积 看到这里，前文提到的数论函数才能真正地起作用. [1] [公式] [公式] 在证明的过程中，我们发现：如果一个函数和 [公式] 作狄利克雷卷积，就相当于把其参数的所有因子枚举出来并代入原函数，然后求和. 也就是说： [公式] 无论是正向操作还是反向操作，这个式子都很重要. [2] [公式] 再提醒一下，[公式] 的定义是这样的： [公式] 首先有： [公式] 尝试对 [公式] 进行拆分，当 [公式] 时，有： [公式] 考虑更普遍的情况，当 [公式] 为任意正整数，分解 [公式]，因为 [公式] 是积性函数，所以： [公式] 综上，[公式]. [3] [公式] 这个证明相对更简单. [公式] 上面我们只列举出了三个常用的狄利克雷卷积结果，分别是： [公式]; [公式]; [公式]. 实际上，通过这几个运算我们可以得到更多的运算，例如： [公式] 单位元 乘法的 单位元 是指乘上它后值不改变的数（对狄利克雷卷积来说，是“函数”）. 例如，普通乘法的单位元是数字 [公式]，因为 [公式]. 因此，在狄利克雷卷积中，它的单位元 [公式] 就应该满足 [公式]. 我们注意到这样一个事实： [公式] 因此，狄利克雷卷积的单位元就是 单位函数 [公式]，它在狄利克雷卷积中的作用和 1 在普通乘法中的作用是类似的. 任何函数（ 包括 [公式] ）和 [公式] 进行狄利克雷卷积，都得到该函数本身. 还记得到吗？[公式] 的定义是这样的： [公式] 狄利克雷逆（Dirichlet Inverse） 我们可以把这里的“ 逆 ”和“ 逆元 ”作类比. 例如，在普通运算中，一个数的“逆元”就是这个数的倒数；在同余运算中，一个数的“逆元”在同个模的意义下，能使得它与这个数相乘的结果与 [公式] 同余. 分别而言，如果我们规定 [公式] 的逆元是 [公式]（这个符号是作为整体引入的， 大多数情况下不能简单地理解为 [公式] ），那么就有这样两个式子： [公式] 数字 [公式] 是两种运算中的单位元，所以说，逆元在类似乘法的运算中起着“倒数”的地位. 在狄利克雷卷积中，单位元是 [公式]，我们定义狄利克雷逆如下： [公式] 函数 [公式] 就被称为 [公式] 的 狄利克雷逆 . 对于狄利克雷逆公式的推导，可以使用 合情推理 的方法（列出 [公式]，然后找规律），得到狄利克雷逆的计算式： [公式] 这个式子我们不推导，仅证明它是成立的: 当 [公式] 时，[公式]. 当 [公式] 时， [公式] 也就是说，[公式]. 因此这个计算式是成立的. 值得注意的是，狄利克雷逆的计算式中包含了自身，也就是说它是个 递归形式的定义 . 若将其展开，则过于复杂，（一般）没有实际意义. 一个数论函数 [公式] 存在狄利克雷逆的 充要条件 是 [公式]，在狄利克雷逆的推导过程中，我们知道 [公式] 的逆是唯一的 . 需要指出， 积性函数一定有狄利克雷逆，且它也是积性函数 ，该证明从略（请参见芝加哥大学 Mark Schachner 的 Paper ）. 当 [公式] 且 [公式] 时，有 [公式]，证明如下： [公式] 由狄利克雷逆的唯一性，[公式] 的狄利克雷逆是唯一的，所以 [公式]. 莫比乌斯反演 说了这么多，终于到莫比乌斯反演了. 了解了狄利克雷卷积和狄利克雷逆，莫比乌斯反演就不在话下了. 我们定义单位函数 [公式] 的狄利克雷逆为 莫比乌斯函数 [公式] （或译作“默比乌斯函数”）： [公式] 上面这个式子就是莫比乌斯函数的狄利克雷逆定义式，如果用普通写法，莫比乌斯函数的普通定义式为： [公式] 其证明请参见 Mark Schachner 的 Paper 中的 Theorem 4.3. 互联网上不少介绍莫比乌斯反演的文章只给第二种定义，是因为莫比乌斯反演的讲解可以绕过狄利克雷卷积独立进行，但这样做会让一些读者不明白为什么这样定义，平添了许多麻烦. 我认为，在理解狄利克雷卷积的基础上谈论莫比乌斯反演是事半功倍的. 使用狄利克雷卷积来推导莫比乌斯反演公式就易如反掌了： [公式] 将其展开，也就是： [公式] 莫比乌斯反演公式的证明十分简单，在 [公式] 式的左式中同时卷积 [公式] 即可. 参考文献 芝加哥大学 Mark Schachner 的论文： Algebraic and Analytic Properties of Arithmetic Functions ; Wikipedia Dirichlet Convolution 条目 ; Pecco 知乎专栏《狄利克雷卷积》 ; Wikipedia Arithmetic Function 条目 . 感谢阅读，如果发现有误或不当的地方，我诚恳地希望您在下方评论区指出. 关于莫比乌斯反演公式的应用及延伸，我会在下一篇文章中提及，敬请期待.","link":"/note/cs/test/latex","is_index":false},{"title":"Markdown 测试","content":"普通文字 二级标题 三级标题 四级标题 五级标题 六级标题 选中 未选中 Sunt ullamco esse esse sit aliquip aliquip ea laboris ea nulla. Quis eiusmod enim aliqua consectetur sit ea. Commodo anim enim sit qui nisi culpa labore fugiat nisi est nulla ad. Dolore dolor magna Lorem sunt dolor commodo eu ad aliquip officia officia incididunt deserunt. Adipisicing veniam aliquip incididunt et amet velit nulla quis magna culpa aliqua nulla. Lorem proident Lorem nostrud elit quis quis id duis incididunt reprehenderit. Magna do ipsum incididunt nisi nisi do et consectetur excepteur amet. Irure qui aute incididunt velit consectetur nisi et sint elit dolor voluptate. Magna et non ullamco minim commodo amet culpa anim ea excepteur consequat pariatur laboris. Duis reprehenderit ipsum officia duis ut veniam. Ex deserunt labore velit minim laboris veniam magna velit exercitation ea minim. Velit amet veniam aute minim. Dolore occaecat officia minim dolor cupidatat ut sint. Tempor voluptate aliquip consectetur excepteur culpa. Et dolor in adipisicing commodo ex magna dolore ut aliquip. Nulla nisi nulla commodo id proident sit proident dolor dolore ipsum ullamco. Fugiat Lorem est sunt excepteur Lorem officia labore. Ut et tempor in exercitation nostrud amet eiusmod. Exercitation incididunt dolore cupidatat mollit veniam esse reprehenderit eiusmod cillum eu tempor dolor aliqua minim. Laboris voluptate consequat exercitation nisi ipsum. Cillum anim voluptate sunt est nostrud magna quis ad irure. 斜体 、 粗体 、 加粗斜体 、 删除线 在一个段落中的 文字链接 ，然后是后面的文字。 无序列表项 1 无序列表项 2 无序列表项 3 有序列表项 1 有序列表项 2 有序列表项 3 图片展示 这里是图片标题，支持 [公式] 和 加粗 文字 cat /data/flag 三级引用。Proident id dolore consectetur eu nulla anim sint magna veniam culpa mollit anim nostrud elit. Laboris ullamco nulla officia esse deserunt est aliqua. Ex deserunt mollit consectetur consequat duis deserunt et pariatur. Labore pariatur dolor ut excepteur amet ex fugiat amet tempor ullamco aute. Cupidatat non nulla ut laborum dolor nostrud quis quis. 二级引用。Exercitation aliquip commodo voluptate sit nulla. Voluptate laborum commodo esse elit culpa velit. Occaecat consequat pariatur deserunt nulla reprehenderit eiusmod. Consequat nostrud labore do laborum anim duis laborum proident laboris elit. Enim culpa aliqua voluptate aliqua dolor esse nisi culpa consectetur anim minim sint nulla incididunt. 一级引用。Et amet ea anim ut excepteur consequat amet dolore. Nulla incididunt do et minim do ea consequat aute dolore. Eiusmod exercitation proident aliqua et officia laborum occaecat reprehenderit exercitation ea ut fugiat pariatur. Anim do veniam ex pariatur proident quis id aute consequat incididunt excepteur quis tempor id. 多个引用 多个引用 多个引用 Cupidatat consequat incididunt nostrud laborum incididunt in sunt aute. Elit consectetur consectetur qui fugiat incididunt laborum amet officia quis cupidatat amet ut ullamco. Esse sunt aliqua commodo qui laboris sint enim. 行内代码块 #include<iostream> 。Mollit dolore est in et aliquip adipisicing et nulla id nulla esse laborum minim nulla. In ad irure qui magna Lorem ad eiusmod do do laborum ex duis . Reprehenderit nulla nisi laborum incididunt voluptate sunt et cupidatat commodo consectetur deserunt. Non officia aliquip enim duis. Ea irure magna excepteur labore eiusmod officia sit id sint anim ipsum duis labore Lorem. Culpa cillum voluptate duis exercitation cillum esse incididunt laborum magna . Est ut commodo non magna nisi sit proident deserunt consectetur ut anim ullamco ut adipisicing. scanf() 用于输入数据，而 printf() 用于输出数据。 表格 Type Description % Prints % . d Decimal signed int . u Decimal unsigned int . o Octal unsigned int . x , X Hexadecimal unsigned int . x for lower-case and X for upper-case. f Float-point types in fixed-point notation. e , E Float-point types in exponential notation: d.ddde±dd . e for lower-case “e” and E for upper-case. g , G Float-point types in either fixed-point or exponential notation, whichever is more appropriate for its magnitude. g for lower-case and G for upper-case. a , A Float-point in hexadecimal notation, starting with 0x or 0X . a for lower-case and A for upper-case. s null -terminated string. c char . p void* in an implementation-defined format. n Print nothing, but writes the number of characters written so far into an integer pointer parameter. 代码块 # include <stdio.h> \\n\\n int main ( ) \\n { \\n printf ( \\\"Hello world\\\\n\\\" ) ; \\n printf ( \\\"Nulla culpa ut laborum sint esse elit minim sit. Eiusmod et exercitation et laboris voluptate aute et veniam excepteur. Anim dolore culpa commodo adipisicing et aute. In est aliquip duis tempor cillum ullamco qui. Et officia cillum ex et dolor esse magna veniam. Dolor sint velit dolor commodo in. Irure excepteur adipisicing dolore ipsum velit ipsum nisi Lorem pariatur dolor excepteur dolor dolor.\\\\n\\\" ) ; \\n return 0 ; \\n } \\n \"}> 这个代码块不带语言标识\\nlet a = 1;\\n \"}>","link":"/note/cs/test/markdown","is_index":false},{"title":"ToC 测试","content":"普通标题 1-1 一些内容 另一个标题 # 这里不应该被识别为标题\\n## 这里也是\\n###and this\\n \"}> 但是这里应该被判定为标题 # 这里不应该被识别为标题\\n \"}> 这里也是 这个标题内还有 [公式] 数学公式 这个标题里面有 code 块 这个 意大利的 标题非常 强壮","link":"/note/cs/test/toc","is_index":false},{"title":"笔记","content":"","link":"/note","is_index":true},{"title":"离散数学","content":"","link":"/note/math/dm","is_index":false},{"title":"离散傅里叶变换和离散傅里叶反变换文字文字文字文字文字文字文字文字文字文字","content":"离散傅里叶变换 （Discrete Fourier Transform, DFT）和 离散傅里叶反变换 （Inverse Discrete Fourier Transform, IDFT） 是鼎鼎大名的 快速傅里叶变换 （Fast Fourier Transform, FFT）的前置知识. 其中 FFT 用于加速两个多项式 [公式]、[公式] 的乘积 [公式] 的计算，DFT 和 IDFT 是 FFT 的两个中间步骤. 需要明确，给定的是两个多项式： [公式] 其中 [公式] 是一个 [公式] 项多项式，[公式] 是一个 [公式] 项多项式. 我们要求的多项式函数 [公式] 为一个 [公式] 项的多项式（考虑最低项 [公式] 的幂次为 [公式]，最高项为 [公式]，共 [公式] 项）. 要了解 DFT 和 IDFT，还需要一些前置知识. 多项式的系数表示法 我们平时用的多项式系数 [公式] 就属于多项式的系数表示法. 我们称 [公式] 维系数向量 [公式] 为 [公式] 的 系数表示 ，其中： [公式] 对于 [公式] 的系数表示 [公式] 和 [公式] 的系数表示 [公式]，要求 [公式] 的系数表示，显然可以通过以下代码实现: for ( int i = 0 ; i < n ; i ++ ) \\n for ( int j = 0 ; j < m ; j ++ ) \\n        c [ i + j ] += a [ i ] * b [ j ] ; \\n \"}> 得到的 [公式] 为 [公式] 项多项式. 这个朴素算法的时间复杂度是 [公式] 的. 多项式的点值表示法 点值表示法是 DFT 算法的核心. 我们在 [公式] 上 任意 取一组 不同 的 [公式]，共 [公式] 个，记为向量 [公式]，这里的 [公式] 称为 插值节点 . 将每个 [公式] 分别代入 [公式]，得到一组共 [公式] 个运算结果 [公式]，记为向量 [公式]. 也就是说，求 [公式] 向量 [公式] 称为多项式 [公式] 的 点值表示 . 下面我们证明，一个 [公式] 项多项式（[公式] 次）在 [公式] 个不同点的取值唯一确定该多项式. 考虑反证法. 假设两个不同的多项式 [公式] 和 [公式]，它们满足，对 [公式]，总有 [公式]. 令 [公式]，则对 [公式]，都有 [公式]. 也就是说，[公式] 次多项式 [公式] 有 [公式] 个根，和代数基本定理（一个 [公式] 次多项式 在复数域上 有且仅有 [公式] 个根）矛盾，假设不成立，证毕. 通过系数表示求点值表示，复杂度为 [公式]. 通过点值表示求系数表示，可以使用 插值 算法，其朴素形式复杂度为 [公式]. 若已知 [公式] 和 [公式] 的点值表示 [公式] 和 [公式]，那么多项式乘积 [公式] 可以简单地表示为 [公式] 设 [公式] 的点值表示有 [公式] 项，[公式] 的有 [公式] 项，为了保证所得能确定唯一的 [公式]， 我们需要在 [公式]、[公式] 中至少取 [公式] 个插值节点 . 倘若能快速地转换 点值表示法 和 系数表示法 ，求 [公式] 的过程就会被大大加速. 确定了方向，让我们来捋一捋 DFT 求算 [公式] 的思路，以便于思考. 输入 [公式] 和 [公式] 的系数表示； 将其分别转换为点值表达式； 通过这两个点值表达式计算 [公式] 的点值表达式； 将 [公式] 的点值表示转化为系数表示，即为结果. 单位复数根模型 互联网上有很多相关的资料，这里只提一下后面要用的引理. [公式]； [公式]； （折半引理）[公式]； （消去引理）[公式]. 确保理解前置知识过后，我们进入正题. 离散傅里叶变换 考虑一个 [公式] 项多项式 [公式]，其中 [公式]，[公式]，不足 [公式] 的补系数为 [公式] 的项. [公式] 倘若取 [公式] 次单位根的 [公式] 次幂，分别代入 [公式]，得到一个点值向量 [公式]. 对给定多项式进行这样操作的过程，称为 离散傅里叶变换 （Discrete Fourier Transform, DFT）. 显然，如果直接代入，DFT 的朴素实现仍然很低效. 考虑对其优化. 对于任意多项式 [公式]，将每一项按照幂次的奇偶分组： [公式] 令 [公式][公式] 那么，有 [公式] 对于 [公式]，[公式]， [公式] 考虑如何简化右式. 注意 ，请牢记 [公式] 是 [公式] 的整数次幂，即 [公式]. 对于 [公式] 的部分（[公式] 是整数）： [公式] 对于 [公式] 的部分： [公式] 注意到： [公式] 和 [公式] 则有： [公式] [公式] 与 [公式] 取遍了 [公式] 这 [公式] 个整数，因此能通过这 [公式] 个点值反解系数. 把这两个式子写在一起： [公式][公式] 只要知道 [公式]，转化为子问题，就可以在 [公式] 的时间内求得 [公式]. 这个过程就是 DFT. 离散傅里叶反变换 将用单位根求出的点值表示的多项式转化为系数表示，这个过程即为 离散傅里叶反变换 （Inverse Discrete Fourier Transform）. 也就是说，要通过插值为单位根的 [公式] 维点值向量 [公式] 推出 [公式] 维系数向量 [公式]. 可以把离散傅里叶反变换理解为离散傅里叶变换的逆操作. 假设 [公式] 进行一次 DFT 的结果是 [公式]. 构造辅助多项式： [公式] 在 [公式] 中，[公式] 是系数向量. 取插值节点 [公式]（[公式]），将其代入 [公式]，得到另一组点值向量 [公式]. 也就是说： [公式] 将 [公式] 还原，并化简 [公式]： [公式] 考虑这个式子的右半部分，令： [公式] 则有 [公式]， [公式] 注意到 [公式] 时，这是一个等比数列. 分类讨论 [公式]. 如果 [公式]，有 [公式]，则： [公式] [公式]，即 [公式] 时，[公式]. 如果 [公式]，有 [公式]，则 [公式] 是公比为 [公式] 的等比数列. 根据等比数列求和公式： [公式] 也就是说，[公式] 时，[公式]. 故 [公式] 是这样一个分段函数： [公式] 将其代入原式： [公式] 得到： [公式] 这里的 [公式] 就是原式的系数. （忍不住说一声，这个式子太简洁了，向研究傅里叶变换的前辈们致以崇高的敬意！） 由此我们可以得到以下步骤： 对多项式 [公式]，将其用插值节点 [公式] 进行一次 DFT，得到 [公式]. 我们再将 [公式] 作为系数，用插值节点 [公式] 再进行一次 DFT，得到 [公式]. 将 [公式] 每一项除以 [公式]，得到的向量就是我们要求的 [公式]. 这个过程就是 IDFT. 快速傅里叶变换 略讲一下 FFT 的原理. 给定多项式 [公式] 和 [公式]，得到其系数表示. 对 [公式] 和 [公式] 分别进行 DFT，得到两个点值向量. 对这两个点值向量每一项相乘，得到一个点值向量. 对这个点值向量进行 IDFT，即得到所求 [公式] 的系数表示. 以后可能会在另一篇文章补上 FFT 的代码实现，敬请期待. Reference 参考 「一小时学会快速傅里叶变换」 by 白空谷 参考 「维基百科 - 离散傅里叶变换」 参考 「维基百科 - 快速傅里叶变换」","link":"/note/math/fourier","is_index":false},{"title":"数学","content":"","link":"/note/math","is_index":true},{"title":"线性代数课程笔记","content":"","link":"/note/math/la","is_index":false},{"title":"Français","content":"字母表 字母 音标 字母 音标 Aa [a] Nn [ɛn] Bb [be] Oo [o] Cc [se] Pp [pe] Dd [de] Qq [ky] Ee [ə] Rr [ɛr] Ff [ɛf] Ss [ɛs] Gg [ʒe] Tt [te] Hh [aʃ] Uu [y] Ii [i] Vv [ve] Jj [ʒi] Ww [dubləve] Kk [ka] Xx [iks] Ll [ɛl] Yy [iɡrɛk] Mm [ɛm] Zz [zɛd] 音素 元音 ： [a] [ɔ] [œ] [ɛ] [o] [ø] [e] [ə] [u] [y] [i] [ɑ̃] [ɛ̃] [œ̃] [ɔ̃] 辅音 ： [p] [b] [t] [d] [f] [v] [k] [g] [s] [z] [ʃ] [ʒ] [m] [n] [ɲ] [l] [r] 半元音 ： [j] [ч] [w] 发音规则 元音 音素 读音规则 例词 [a] a, à, â sa, là, âme [ɛ] è, ê mère, fête ai, ei fait, veine e 在闭音节中 sel e 在两个相同的辅音字母前 cette et 在词末 filet [i] i, î, ï mie, île, maïs y style [e] é bébé es 在单音节词中 des er, ez 在词末 fêter [fɛte] , aidez [ɛde] [y] u, û tu [ty] , dû, culture [kyltyr] [ə] e 在词首开音节中 chemise ʃəmiz e 在单音节词中 ce [sə] e 在“辅辅 e 辅元”中 vendredi [ã] am, an 后无 m, n 或元音字母 lampe, dans em, en 后无 m, n 或元音字母 temps [tã] , vent [vã] , an [ã] 辅音 音素 读音规则 例词 [s] s tasse ç ça, français c 在元音字母 e, i, y 前 face, cidre, cycle [t] t, th ta, thé [d] d date [f] f fade ph phare [v] v vie [m] m mais [ʃ] ch chaise [ʃɛz] , chine [ʃin] [ʒ] j jupe [ʒyp] , déjà [deʒa] g 在元音字母 e, i, y 前 âge, gile, gymnase [k] k kaki c 在元音字母 a, o, u 或辅音字母前 car, code [kɔd] , cube, classe c 在词尾 lac lak qu quel [kɛl] [g] g 在元音字母 a, o, u 或辅音字母前 gare, gomme, légume, glace gu 在元音字母 e, i, y 前 guerre, guide [r] r rire, revue [rəvy] [z] z zèle s 在两个元音字母之间 Asie","link":"/note/misc/french","is_index":false},{"title":"杂项","content":"","link":"/note/misc","is_index":true}];
const config = {"keys":["title","content"],"includeMatches":true,"ignoreLocation":true,"threshold":0.4};
const index = Fuse.parseIndex(idx);
const fuse = new Fuse(db, config, index);
export default t => t ? fuse.search(t) : db;
